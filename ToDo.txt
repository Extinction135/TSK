"As we enjoy great advantages from the inventions of others,
we should be glad for an opportunity to serve others by an invention of ours,
and this we should do freely and generously."
- Benjamin Franklin	
	
Gif Capture process:
	run game in release mode
	run LiceCap, expand capture area past program window about 10 pixels on each side
	record at 30fps, open in photoshop and crop the frame down to just the game view (minus window title)
	reduce image size by half, down to original size so pixels are 1:1 ratio
	save as PSD master, then begin cutting out sections/edits
	the default time per frame (set by licecap) is perfect, do not change this
	save for web ->  GIF 32 Dithered, filesize should be under 3mb, loop forever
	test in browser to ensure proper fps
adding music:
	files are saved as .ogg and added to content pipeline, built on high quality.
	keep these files stereo, but at 22k.
adding sound effects:
	sound effects should be compressed down to 22K sample rate, mono, 16bit
VS shortcuts
	CTRL + M, O = collapse functions/regions	
new gif: 50% nearest neighbor, 32 dithered
adding a cheat:
	add value to MenuItemType enum (cheat starts as a selectable menu item)
	update MenuItem.SetType() to set cheat menuItem descriptions, titles, and initial frame.
	add menuItem to Cheat Screen.
	link neighbors, add effect, add check to SetCheatMenuItems(), playtest.
Adding GameObjs:
	make enum defs, make animFrames,
	set objType paths, add to env obj widget
	playtest in field.	
	
	
Phase 1 - version 0.1 to 0.7 (complete)
zelda with a procedural, randomly generated dungeon, and
better movement / dashing / combat on xbox one + pc.

Phase 2 - version 0.8 to 1.0
+ Miyamoto's original lttp ideas.
+ all desired functionality from lttp + other zeldas.
+ all desired functionality from other games.
+ mature, dark story + endgame content.	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
v0.8 goals

- the "shadow system"
every actor has a shadow, based on the actor size and flying state.
larger actor = large shadow, flying actor = smaller shadow (due to height off ground)
every object has a shadow, based on the obj type, size, and state.
these shadows maybe visible or not. these shadows should track to the
objects/actors each frame, AFTER the compMove component has finished processing.
these shadows are sprites that are added to actors and gameobj classes.
this will likely be part of pool, possibly just prior to drawing to ensure
they are always aligned to their obj/actor (altho this does pollute Draw)..

- Non-room repeating Dungeon, additional rooms
- Flying Dungeon Enemy, Minor Overworld Enemies
- Blob AI improvements - sword, arrow, bomb based on weapon / item loadout 
- blob loadouts could be randomized when room is built()

- mountain dungeon (diff enemies, boss, dungeon sprites - but same rooms)

- room keys - these only work for the room and only unlock 1 door, and
these rooms turn all their doors into locked doors upon close, similar to puzzled rooms
link doesn't put them into inventory, he literally picks them up and takes
them to the door to unlock it. this is super mario style key gameplay.
if link's heldObj == small key, then link's interaction with locked door makes it open.
and heldObj is released().




0.9
- LIGHT WORLD & DARK WORLD
- this is different overworld map + different levels + diff sprites
- this is NOT A SEPARATE SYSTEM (needless complexity)






TODAY:











Chimney++

chimney smoke should only happen
if chimney sprite alpha is at 1.0.
any value below that is ignored.
why? because chimney creates smoke
as it's fading in/out, leaving
smoke particles on their own once
chimney completes it's fade,
looksBadMan.jpg. fixed.







building side walls should sort under
building front walls - we're getting
visual sorting bugs.



move gass feetfx sprite up 1 on y axis in sprite sheet.
this will align better to hero and blob actors.










colliseum level
what is this? we need npcs and unique sprites here too.
define what colliseum is and how hero interacts with it.


town level
has houses and shops, with NPCs






weapons and equipment should be located in the same large building.
items should be located elsewhere.





























We need dirt paths, without using alot of sprite space up.
we could do vert transition to dirt + hori trans to dirt,
but never actually have a dirt tile. putting two of these
together could build a path, and then we just need corners.
so, minimum of 4 - likely 6.


























Fire++
when fire expands, it should expand further vertically,
because it doesn't always transfer from bush to bush,
because bush hitboxes are small.







HitBoxes++
we're always expanding and contracting the hitBox.
we need dedicated methods for doing this.
we need to override/replace/rewrite xna's rectangle class.
but we need to keep the intersects() and contains() methods,
as they are, as fast as they are.






Exploit : Trap Door Pit Teleport

the majority of what i do as a game developer is deal
with cause and effect, how systems interact, and designing
systems that do their job BUT ALSO get along with the
other systems that exist in the global namespace (ecosphere).

currently the system designed to track what door link
went thru last is causing a problem with the system that
represents the pit's functionality. this occurs in this
particular state, and likely in others:

hero enters a puzzle room where the doors become trap
doors (this is only way to get trap doors). hero moves
to a different trap door, touching it, activating it
as the last door 'entered'. hero is then pushed, or
falls into a pit (maybe with a certain direction).
this causes the pit to pull hero in, then call 
RespawnInCurrentRoom() on the hero, teleporting him
to the last touched door, the 2nd trap door. with
enough inertia, the hero can overcome the trap door's
initial frame of pushing, and link can pop out into
the room on the other side of the 2nd trap door.
i experienced this exploit personally. not sure if
it would work on vertical North/South doors, as
it only happened to me for East/West doors.
this is *likely* what's happening, tho I'm not
exactly sure - but I do know how to fix it.

the fix is simply to remove trap doors from the
routine that sets the last 'touched' door / active door.
in fact, only open doors or bombed doors should be
set as the last / active door.






Ditches

*bug: the ditches dont load properly,
any ditch that should be flipped horizontally
isn't, because we dont save that data.
we dont need to save that data, we can 
actually 'rebuild' the ditches once we
complete loading a room. or we can never
really build ditch connections, just single
ditches here and there to give player a clue.
add the single ditch obj into editor, so
editors know what can be saved / used in a level.
in addition, we should only let single ditches
be saved - no other ditches can be saved!
this makes ditches primarily an interactive
system, and not a system used when loading
rooms or levels.






Editor ++
when we press F3, the top menu is hidden, but we can
still click on the buttons, which is bad when we're 
trying to complete a level. until then we can't complete
the farm level's water tiles.




Commentary
test recording playthru using astro a20s.
can we hook this into OBS? why not?






Boomerang Bug?
ran into lost boomerang bug again.
simply left a room with it bouncing around.



when water spreads to other tiles, it shouldn't play
the water splash soundfx, this takes waaay too long.
it should play the water walk sfx, or we should shorten
the water splash sound fx dramatically. either or.
or we should create a water spreading soundfx,
then use the splash fx shortened. i dunno.

 
 
 
 
 

Improve Projectile.Spawn()

*miniboss cant shoot fireballs south - why?
?= pro.spawn() assumes that the actor's collRec is 16x16 - it shouldn't.
this means only 16x16 actors can safely shoot fireballs without damaging
themselves, which is some valve level stupid. this method should take
the actor as a parameter, and then we should base the offsets FOR ALL
PROJECTILES off of the actor's collision rec width and height. this
would allow larger actors, like bosses, to SHOOT FIREBALLS. geez.






Special Attacks / Boss "USE"
bigeye uses the shut + bloodshot frames for his special.
bigeye: spawns A TON of exploding seekers while in his special.







if the hero is swimming, he shouldn't make water walking splash noises.








Standard MOB

create the standard 3 hit floating eye mob for forest dungeon.
this will replace the blob's currently being spawned.
this actor is FLYING btw.




Enemy Spawns

standard - usually 3 hit.

easy - 1 hit, usually many or they explode.
- we have seekers, they need to be renamed.
- we also have fun floaty eye that should be mob outside of boss room

*hard - more than 3 hits, less than 10.
-we dont have a hard boss for forest dungeon yet.
-make one



Enemies++

Seeker : seeks towards player, exlodes (done)
Standard : 3 hits, with a melee attack (usually sword).

OneHit : fast moving, low melee, low health.
Distance : projectile attack (unlimited), med move, low health.
Healing : healing magic (set amount), med move, no attack.
Aggro : tank, slow, strong melee attack.
Flanking : rogue, weak, fast, with strong attack.

Miniboss : done
Boss : done



we'll need to change the enemy spawn 2, or miniboss spawn to be
Enemy_Spawn_Weak, Enemy_Spawn_Strong. later on, it's likely this 
will expand to also include Enemy_Spawn_Ranged, Enemy_Spawn_Healer,
etc...




Underground Blob Dungeon:
we have an overworld pit sprite.
hide this randomly under an object that can be destroyed,
like a bush on a level. for now, this object will
create a new type of dungeon, an underground dungeon.
this is just a single critical path from hub room to exit room.
just a hub room, then an exit room south of it.
in the hub room, a miniboss will spawn, with a chest.
the chest will have the dungeon map, in case we decide to expand
this dugneon algorithm to be more than 2 rooms in the future.
but, this reverses the dungeon - leading to the exit.
upon exit, we simply return hero to his last overworld location,
which should be stored in save data.
*these dungeons should be blob enemy only, because this is story*





Blobs need to have more weapons & items to attack and use.
Plus, we need to expand the AI to use more items.
this also means we need to change some of the use checks for pool.hero
into checks for actors with those animFrames, by actor type,
like this: actor.type == ActorType.Hero or ActorType.Blob.







Editor++
Update editor to allow for development of complete field rooms.
when we hold down an arrow key, offset the camera by 64 pixels in
that direction. this allows us to 'peek' beyond a levels bounds.



we can handle plot/level changes like this:
we have a boolean that represents this levels state.
false loads xml data A. true loads xml data B.
the differece between A and B represents something
that happened in the story, or something the player did.
-perhaps the player killed an NPC.
-perhaps the player irrigated a farmers crops (B would have filled ditches, A wouldn't).
-theres alot we can do here.






Boomerang++
*boomerang should only create attention particles upon hit if
it's traveling away from hero. if it's returning to hero (it's lifecounter)
then it shouldn't create ANY attention particles. this fixes
the visual bug where it can create a ton of pops when hitting
objs from certain angles / directions.




Metal Gear ++
if you're carrying an obj and press B while not moving, link
should squat down and the heldObj should sort mostly over his head,
and he should flip the actor.hidden boolean. then update functions_AI
to check the actor.hidden boolean instead of the actor.underwater
boolean. then update the underwater rountines to set the actor.hidden
boolean to true when actor dives underwater. the net effect of these
changes is that the hero will be able to hide underwater, underwater
while carrying an obj, or on land while carrying an obj. 
being able to hide on land while carrying an obj is more metal gear
than being able to dive while holding an obj. lol.



in hard mode, pits should deal 1 damage.
in normal mode, pits deal no damage.







*consider that actors may need interaction points*
*needed if actors want to pickup or dig, and it would be nice to see that
with more advanced enemies later on*
migrate hero's interaction rec and interaction rec functions into actor class.



