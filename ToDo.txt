
CTRL + M, O = collapse functions/regions
CTRL + M, P = expand functions/regions



todo:


created dungeon.cs, with defs for RoomType enum and Room struct.
created stub for Dungeon struct.
created DungeonGenerator.RandomizeRoom().
created instance DungeonGenerator.room.
changed name of CreateRoom() to BuildRoom().
Moved randomization routines from BuildRoom() to RandomizeRoom().
updated codepaths to call RandomizeRoom() then BuildRoom().
extracted various fields from BuildRoom() loops to single instances in DungeonGenerator.
this prevents needless garbage creation when BuildRoom() is called.



create Room struct, that holds all the data that describes a room in the dungeon
	position X, Y
	size X, Y
	type (normal, boss, key, hub)
	
seperate the randomize routines from the build routines in dungeon generator
	call randomize, then build routines from debugMenu

move all (new) fields out of CreateRoom() to explicitly prevent garbage creation/collection







hero should have a shadow (baked into sheet)
blob shadows are TOO dark, should be around 60% opacity


implement fireball magic item
this is a projectile that moves
created, placed, aligned the same as sword

each actor should have a weapon enum
weapons { none, sword, bow, staff, axe, net }
	
	a projectile has: sprite, move, animate, collision components
	a particle has: sprite, move, animate components
	
	this means we'll have a projectile pool, and a particle pool
	
implement dash smoke as a particle (should spawn whenever an actor dashes)
	

	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
debugInfo displays the floor index, instead of the # of floor tiles used currently
which isn't really a problem, cause we're going to optimize how floors are drawn later on

OPTIMIZATION
if we don't draw the floor tiles, the draw loop is much faster
so, we could standardize the room sizes, then create a floor sprite
then instead of drawing 200 floor sprites, we just draw 1 larger floor sprite	
	
	
	
	
	
	
	
	
	
	
	
	
	
define room.cs, which describes the width and height of a room, and has a .type enum
	create a room instance, then pass that to the room creator routine
	place enemies all around within the room, they should not overlap
	place hero in the center of the room
	
add editor buttons to top of window: draw collisions on/off

dungeon.cs
	a collection of rooms (including an exit, hub, key, + boss room)
	draws the current room
	
room.cs
	rectangle (collisionRec) : size + position
	type
	

	
load in a background sound file (to determine how much space this will take up)
this file should be loaded into the SCREEN's content manager
a screen's content manager should be unloaded when the screen exits
this allows us to load different music for different screens, without touching assets.cs

this sound file should be a set number of bars long, at the standard length
this should be mono, as compressed down as you can
can we use mp3? that would be ideal
does an mp3 get uncompressed when loaded into game? 

re-export sound files aligned to specific bar requirements
this will require some rewriting / restructuring of melodies and chords


sound manager should be handled just like screen manager
part of game, passed as ref to each screen
so a screen can just say "soundManager.whatever()"

