"As we enjoy great advantages from the inventions of others,
we should be glad for an opportunity to serve others by an invention of ours,
and this we should do freely and generously."
- Benjamin Franklin	
	
Gif Capture process:
	run game in release mode
	run LiceCap, expand capture area past program window about 10 pixels on each side
	record at 30fps, open in photoshop and crop the frame down to just the game view (minus window title)
	reduce image size by half, down to original size so pixels are 1:1 ratio
	save as PSD master, then begin cutting out sections/edits
	the default time per frame (set by licecap) is perfect, do not change this
	save for web ->  GIF 32 Dithered, filesize should be under 3mb, loop forever
	test in browser to ensure proper fps
adding music:
	files are saved as .ogg and added to content pipeline, built on high quality.
adding sound effects:
	sound effects should be compressed down to 22K sample rate, mono, 16bit
VS shortcuts
	CTRL + M, O = collapse functions/regions	
new gif: 50% nearest neighbor, 32 dithered
adding a cheat:
	add value to MenuItemType enum (cheat starts as a selectable menu item)
	update MenuItem.SetType() to set cheat menuItem descriptions, titles, and initial frame.
	add menuItem to Cheat Screen.
	link neighbors, add effect, add check to SetCheatMenuItems(), playtest.
Adding GameObjs:
	make enum defs, make animFrames,
	set objType paths, add to env obj widget
	playtest in field.	
	
	
	
	
	
	
	
	
	
	
	
	
	
v0.7 goals
x - divide spritesheets up so they can be expanded / modified easily
x - get all objects integrated into the new system / layout
X - expand RoomBuilder to include the creation, placement, loading and saving of world levels.
X - Outside Town Level, vendors

X - Dungeon Entrance Level, dungeon entrance object
X - obj linked to dungeon generation + extensive testing

- picking up, carrying, throwing objs
skull pots, pots, bushes - all deal 1 damage

- the "shadow system"
every actor has a shadow, based on the actor size and flying state.
larger actor = large shadow, flying actor = smaller shadow (due to height off ground)
every object has a shadow, based on the obj type, size, and state.
these shadows maybe visible or not. these shadows should track to the
objects/actors each frame, AFTER the compMove component has finished processing.
these shadows are sprites that are added to actors and gameobj classes.
this will likely be part of pool, possibly just prior to drawing to ensure
they are always aligned to their obj/actor (altho this does pollute Draw)..


- healers house, full death/respawn loop in game
- this includes buildings, beds, interior objs

- Non-room repeating Dungeon, additional rooms
- Flying Dungeon Enemy, Minor Overworld Enemies
- Blob AI improvements - sword, arrow, bomb based on weapon / item loadout 
- blob loadouts could be randomized when room is built()

- EndlessForest Demo (shows off gameplay, complete on it's own, camera tracks to hero).
- this is randomly placed bushes / trees / grass + ANY enemy type
- room rec tracks to hero, expanded room rec cleans up anything that doesn't touch it
- as room moves, *generate random stuff just OUTSIDE of room rec*
- this means, as hero moves he is always 'finding' new stuff, even if he doubles back
- npc outside endless forest dialog = "once you go in, there's no way out..."
- later on implement magic mirror, which returns hero to overworld screen

(2 'dungeons', 2 'locations' - colliseum + healers house)






TODAY:



XML TO CS converter
convert xml to roomData stored in a .cs file, linked to from both projects.
all roomData is then loaded from this .cs file, which will likely be thousands of lines long.
this would be part of editor, a button to update the cs/roomData.
we would still be developing rooms using xml data.
but upon a build, the game would pull all roomData from the cs file, which
should be a global class, like RoomData, that contains all the rooms.
the rooms must have proper id and obj lists. and there will be many of them (eventually).
this may actually be a better way to manage the rooms and levels, because we
can debug trace the cs file in visual studio to ensure it's syntax - something
we can't do with external xml (instead we just get: error at xml file 20,2).













when we change rooms, we reset the particle pool (hopefully)
when we call that reset, we should be resetting ALL particles,
even ones that are alive currently.








Hardmode

we need the option to re-enable puzzles for hard mode. this means progression
thru the dungeon isn't tracked, and puzzle rooms reset upon entering them.

we can enable this option by adding a boolean to flags, something like 'oneTimePuzzles'.
if we disable the boolean, then we call SetupPuzzles() at the end of a room build.
adding this oneTimePuzzles idea is conceptually the beginning of 'hard mode',
where room puzzles reset upon build.

this needs to be added to the options screen, oneTimePuzzles.







TallGrass++

link walking on tall grass should create small grass at link's feet, partially hiding them.
any grounded actor walking in tall grass should get "grassy feet".
so this is a sprite that lives in the actor class, tracks to the actor's feet,
and is only visible when actor is passively interacting with tall grass objs.





Arrows++

arrows should stick into objects until they expire from age.
when the arrow hits an obj, the obj becomes the arrows caster,
and arrow then tracks to it's caster with it's offset from obj (that frame).
this will cause arrows to stick into objs, even objs that move.
we can even switch this arrow projectile for a stuck arrow projectile,
that is simply decoration (we must keep arrow as projectile so it can track to caster)






bush debris - hitting a bush should create leaves that travel in the direction of the hit
leaves only last for a moment, then die
blowing up a tree should create lots of leaves in random directions

when player presses A on dialog screen entering dungeon, play door opening sound.
this sound should not play when the hero spawns in the dungeon, where i think it does
it plays after the dungeon is built?

input polish
when moving the joystick diagonally, the input *should* split evenly between up and say right.
if i'm 60% up and 40% right, it should be up. right now, that diagonal just sets to right.
even if it's 90% up and 10% right, it's set to right. it should be a 50/50 split.
that will increase the precision of sloppy diagonal weapon attacks, aiming their intended direction.

hero should spawn facing up in dungeon.
hero should spawn facing down after exiting dungeon.

the net should map to the Y button, after all, it IS an ITEM.







Then we need to create the healers house, with the spawn point being the bed.
we need a bed obj, building objs, healer npc (with dialog)

then the proper death loop needs to be implmented in-game...

death loop:
if the hero is in game, then hero respawns at healers house.
if the hero dies while the game is in editor mode, then the hero comes back to life.
healer tells link that 'a mysterious stranger brought you here'.
the idea being that queen zelda can sense his suffering and disguises herself in
order to silently save him, to keep him on his path to her, as her plans intend, 
so she remains in control of everything. this should be revealed at the end of the
game, in the final dialogs.










































0.7 polish








Non-Repeating Rooms in Dungeon

we need to make rooms non-repeating in the dungeon.
it's cheap to come across the same room over and over again.

so when the dungeon is being built, we need a list of rooms (based on loaded room data)
then when we place a square room, we ID it, and strip that room off the roomsList
and if we run out of square rooms, then we just try columns, or rows.
this way the dungeon algorithm can never reach a point where there are no more rooms to use
which would be game breaking. also, we need ALOT of rooms to build from.


row rooms need to be redesigned to be MUCH better
we need more rows and column rooms, and their quality needs to be improved.





we need a flying enemy - like a BAT






in save data, we should have the fields named:
heartsMax, magicMax, bombsMax, arrowsMax.
we don't need magicTotal anymore.

do we actually use actor.compInt (this is the interaction component) ??? wtf

fix how kick sountrack volume is handled
the hero's health sets the volume of the kick soundtrack
this check should be happening in the level class, not anywhere
in the assets or music classes, because the kick volume is only
changed during the level screen's life. when the screen closes,
it should ensure the kick volume is 0. this prevents issues we've
had before where the kick volume was above 0 while player was on
different screen.

we should include a soundFXinstance on actors that points to one of the soundFX in assets
then we can set this instance in ActorFunctions.SetType()
then later just call it generically, like Actor.AttackSound.Play().
same with hit sound, death sound, use sound.










































































Implement Light World and Dark World RIGHT NOW
because we need to understand the architecture this is going to need,
before we start tacking a bunch of levels onto the system.
plus, we need to polish the transition between the dark world
and the light world..



v0.8 goals

- LIGHT WORLD & DARK WORLD
- implement enumFields for building rooms (big optimization)

- fix picking up, carrying, throwing, dropping, dragging, pushing objects
- can drag: light blocks, dungeon statues, barrels, torches on/off, chests
- can pickup, carry, throw: pots
- remove dropping pots from game, hero can only throw them

- create 'boat' level, with boat captain, who has dialog with link
- offers to take link to a variety of locations, using vendor screen
- only available location is water temple, for low gold price (since link 'hires' crew)
- this level is the boat obj + a dungeon entrance obj + a bunch of water tiles (maybe a small island)
- links path is to/from the boat to the dungeon entrance

- water temple / swamp dungeon: 
	build crit path to hub, crit path to key, crit path to boss, 
	*crit path to water switch (pullable lever)
	*place water switch randomly in room/hub room
	water pullable lever flips high/low water level boolean
	when rooms are built they build high or low water levels, 
	low water levels prevent hero from passing thru rooms 
	there are low water levels in rooms along the key or boss crit path.
	hero must flip switch to access key or boss rooms, or not.
	boss is tentacles squid
	
- can swim, 'dive', dash, and reward / pickup stuff in water
- dive: 
	in shallow water, this picks up whatever is hidden using reward state.
	in deep water, this allows hero to move 'under' some blocking objects
	diving is timed / capped at 255 frames, after that link pops his head back up
- dash:
	works the same in shallow and deep water, but can't be done while diving
	
- mountain dungeon (diff enemies, boss, dungeon sprites - but same rooms)

- room keys - these only work for the room and only unlock 1 door, and
these rooms turn all their doors into locked doors upon close, similar to puzzled rooms








v0.9 goals
??? story, secrets



v1.0 goals
??? support, testing, videos, documentation, alt marketing














