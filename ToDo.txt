GIF 32 Dithered, Quality: NearestNeighbor @ 50% size

CTRL + M, O = collapse functions/regions
CTRL + M, P = expand functions/regions

goal: 13 commits/day

adding a new particle/projectile:
	add new gameObject type for PP
	add new gameObject animation list for PP
	add codepath for PP to GameObjectFunctions.SetType.
	add call to spawn PP somewhere
	maybe set the alignment of PP in ProjetileFunctions.AlignProjectile()
	maybe projectile interacts with Actor/Obj in InteractionFunctions.Handle()
	
adding soundFX
	added ___Src and ___Ins soundFX to Assets.cs.
	added "_____" sound effect to project.
	updated Assets.Load() to load Sound into ____Src + ____Ins.
	call Assets.____Ins.Play() from somewhere in the codebase

adding music:
	music should be compressed down to 22K sample rate, mono.
	files are then saved to .ogg and added to content pipeline, built on high quality.
	
ram useage:
	76mb on Win10.  82mb on XboxOne.
	
	
	
	
	
	
	
todo:


2


removed Initialize() functions from Input, and Camera2D.
it makes no sense to use an Initialize method when it can be done automatically with the constructor.
slight reorganization of ScreenManager.
playtested, working as expected.


	


 
	
menuItems should have an enum field in them
then we pass the menuItem to MenuItemFunctions.SetMenuItem(menuItemEnum).
this function sets the current frame, name, and description based on the enum passed.
this localizes all the menu item data to the MenuItemFunctions class.

we need to populate all the menuItems with data
this will be done through the MenuItemFunctions.SetMenuItem(MenuItemType enum)
-> sets the name, current frame, and description based on passed enum


we really do need a different sound effect for when the user presses A button on menuItem























later in development, when we have a game options screen,
the options widget will need to reset it's neighbors, so it doesn't connect to widgets not visible
these menuItem neighbors will be set when the inventory screen is created
	
we'll reuse options window on the title screen, and info window
inventory screen can be called from overworld screen as well
	
	
	
	
	
	
	
	
	
a special explosion sound should play when the boss is defeated




move DebugMenu.Draw() into DrawFunctions, cause that's where it belongs.


seperate the Drawing and Updating of DebugInfo fields from Draw().
the drawing should occur in DrawFunctions.
the update should occur in an update() function that is called from dungeonScreen's Update.



we need boss music, and that music should play when hero enters boss room

what else do we need to do to prep for v0.2 release?
theoretically we could 'rollback' to v0.1 and record a short video.
then record a video for v0.2.











Version 0.2 Release
	
	mostly done.
	record GIFs of spawn room + boss room
	create a markdown file for the repo that shows version 0.1 + features
	then it should show the progression to v0.2 + features
	include GIFs for v0.1 + v0.2
	
	
BUG?
boss should collide with hero - right now he doesn't
this means the boss 'locks' the hero when he collides with him - the hero can't move
this also leads to a state where the boss can spawn a blob ON TOP of hero, locking them both
** actually, the codepath in collisionFunctions.CheckActorPoolCollisions only ignores collisions..
between blob and boss. Boss + Hero collisions should still be valid/true..
but i've noticed that the boss overlaps/locks the hero still. at least it feels that way.
so... not sure what the issue is: either i'm imagining the lock, or it's actually locking....


















	
Version 0.3 Milestones

	pickup and throw
	hero should be able to pickup the skull pot objects
	hero should be able to carry the skull pot objects around
	hero should be able to throw the pots in a direction
	pots should travel for a bit, with a shadow, before colliding with ground
	pots should also collide with room objects
	pot should have sound for pickup, throw, explode/death
	pots should randomly spawn loot too, when they are picked up
	
	dragging/pushing/pulling
	hero should be able to 'grab' objects
	if the object is draggable, then hero should be able to push and pull on it
	this 'grabbing' state should last until player releases the A button
	objects should inherit the movement of hero, and check collisions with all objs & actors
	if a draggable object would collide, it doesn't move
	
	fireball projectile
	hero should be able to spawn a fireball projectile with Y button press
	this should move in the direction the hero is facing at the time
	projectile should collide with objs + actors
	fireball should deal 1 damage to actors it collides with
	fireball should 'die' upon collision
	fireball should have a cooldown so hero can't spam it
	fireball should have a soundfx for spawn, collision/death
	
	overworld screen
	use the background from hyper light drifter for now
	use the approach of moving the background image against the cursor movement (from destiny)
	there should be a spining/pulsing cursor icon, like destiny
	player should be able to select from a few 'locations' on the map
	the cursor should be 'sticky' like in destiny
	clicking on a location exits the overworld screen and builds a dungeon
	
	exiting dungeons
	the spawn room should have a set of exit objects that resemble an exit door
	if hero collides with the inner most part of the exit door, then the screen exits
	and the overworld screen is created, which lets player choose which dungeon to go to next
	

	
	
Version 0.4 Milestones	
	
	ROOM EDITOR + ROOM DATA
	build the room editor screen
	standardize all room types + sizes
	create the room data folder, update cs project to copy room data to output folder
	basically the same approach as CC, but we'll be storing the room data in a slightly diff format
	we'll only store room objects + enemy spawn locations - no floors, projectiles, etc..
	and we'll only need to store the object's enum value
	this will be stored in a 2d list of Column{Rows}.
	so row1 = {0,0,0,0,0,10,10,10,0,0,0,0,0} for example, where 10 is an object type and 0 isn't.
	this was we don't have to store position data, we just correlate rows to room width, and columns to room height
	width and height is set based on room type, so we'll need to save room type.
	but thats it. room type + the 2d array of int values.
	pretty compact and efficient.
	
	COMPELTE DUNGEONS
	we'll be using room editor to build up the room data folders.
	then when we build the dungeon, we'll load all the room data into the game at once.
	when we need a specific type of room, we just copy the necessary room data.
	then we place the room where we need it, and build it.
	this is done over and over again, until the complete dungeon is built.
	we'll use the same routines from CC to build the Exit -> Hub -> KeyPath -> BossPath layout.
	
	
	
	
	
	
	
	
Stuff that needs to be done, but it's not terribly important rn	
	
	we need to implement the empty heart idea in the worldUI
	this means hero should have values for current hearts, and maximum hearts
	maximum hearts can never exceed 14
	
	we should include a soundFXinstance on actors that points to one of the soundFX in assets
	then we can set this instance in ActorFunctions.SetType()
	then later just call it generically, like Actor.AttackSound.Play().
	same with hit sound, death sound, use sound.

	add wall pillar decorations when room is built
	doors should have decorations around them as well

	hero should spin around prior to dying
	other actors should not do this, they should die immediately
	the dungeon screen should only start it's fadeIn if the hero is in his final sitting death state
	it should remain 'playing' while hero spins around
	
	we could have the boss drop an EGG projectile, which takes a few frames to 'hatch'
	when the egg hatches, a blob actor could be placed there
	this would prevent the blobs from overlapping each other
	well, actually no - because an actor could overlap the egg as it hatches.. hmmmm
	
	create pause screen, can select different weapons / items
	also displays total gold
	
	expand weapons to include moar { sword, bow, staff, axe, net }
	link pause menu to weapon enum
	
	create shop sreen, can purchase different weapons / items for gold
	implement purchasing routines (gold)
	
	play overworld music for overworld screen
	play shop music for shop screen
	
	implement additional weapons / items
	weapons : { bow, staff, axe }
	items : { lightning, boomerang, arrow, bomb }
	
	adopt CursedCastle's roomData approach (Editor -> XML -> Randomly Choose a Room)
	update dungeon generation routines to build complete dungeons
	create room editor, standardize room sizes
	
	
	
	
	
	
	
	
	
	
	
	
	
	
Maybes / Ideas	

	blobs should vomit a cloud, which acts as a close range projectile, with a short lifetime
	or they can use a weapon, like a stick or gooey hand, iunno

	debugInfo displays the floor index, instead of the # of floor tiles used currently
	which isn't really a problem, cause we're going to optimize how floors are drawn later on

	OPTIMIZATION
	if we don't draw the floor tiles, the draw loop is much faster
	so, we could standardize the room sizes, then create a floor sprite
	then instead of drawing 200 floor sprites, we just draw 1 larger floor sprite	

	OPTIMIZATIONS
	drop the sample rate down to 22k to save even more space on bkg music files
	the soundfx are already at 32k, so we know lower sampled audio builds and loads correctly


