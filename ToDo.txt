CTRL + M, O = collapse functions/regions
CTRL + M, P = expand functions/regions

goal: 13 commits/day

adding a new particle/projectile:
	add new gameObject type for PP
	add new gameObject animation list for PP
	add codepath for PP to GameObjectFunctions.SetType.
	add call to spawn PP somewhere
	maybe set the alignment of PP in ProjetileFunctions.AlignProjectile()
	maybe PP interacts with Actor/Obj in InteractionFunctions.Handle()
	
	
	
	
todo:


12



removed background from summary screen.
moved this fading rectangle idea into dungeon screen, renamed to overlay.
migrated the alpha + fade speed to dungeon screen too.
created state enum for dungeon screen, with fadeOut, playing, fadeIn, waiting states.
this is in prep for better interactions with the summary screen.

changed AiFunctions.Think() to SetActorInput() to better reflect what it's actually doing.
consolidated UpdateActiveActor's functionality into AiFunctions.SetActorInput().
removed UpdateActiveActor() from PoolFunctions.cs.

AiFunctions.SetActorInput() now manages the active actor count + active actor reference. 
Moved calls to SetActorInput() to DungeonScreen.HandleInput().
This groups all the input calls into one function, making it easier to understand / manage.
Updated HandleInput() to only allow player + AI input to actors if screen is in 'playing' state.

Changed summary screen's state enums to {AnimateIn, Display, AnimateOut, Exit }.
This better reflects each states purpose, as the screen is no longer fading in/out.
Updated SummaryScreen.HandleInput() to set state to AnimateOut upon button press.

Update SummaryScreen.Update() to manage the screens components with respect to screen.state enums.
Title sprites now animate in and out, while text components fade in and out.

moved the call to reset the input out of Input.MapPlayerInput, into DungeonScreen.HandleInput().
this allows us to reset the hero's input, then prevent additional input if the screen isn't in playing state.

now processing only 1 enemy per frame for AI. 
now properly resetting that enemies input prior to DungeonScreen.state.playing check.
this means that when there are less actors on screen, they get updated with AI more frequently.
this should make them harder to beat, which scales the difficulty up or down depending on enemy population.

updated dungeonScreen.Update() to manage the screen's states (fadeOut, playing, fadeIn).
Waiting state literally does nothing. It just waits.
updated dungeonScreen.Draw() to draw the screen's overlay rec last, over everything else.

removed DungeonScreen parameter from Pool.Initialize - it's unused!
created DugneonGenerator.Initialize(DungeonScreen).
DungeonGenerator now stores a reference to DungeonScreen.
this allows DungeonGenerator.BuildRoom() to set the screen.state to FadeOut.
slight reorganization of DungeonGenerator.BuildRoom().


created GameState enum in DungeonScreen to represent Playing, Won, and Lost game states.
renamed Screen.State enum to ScreenState to better describe it's purpose, fixed references.
updated DungeonScreen.Update screen state waiting check to create summary screen based on GameState enum.
updated WinLoseFunctions.Check() to accept DungeonScreen as a parameter.
Check() now sets the gameState enum and does not create a SummaryScreen.
updated DungeonGenerator.BuildRoom() to set gameState to playing upon room creation.
updated WinLoseFunctions.Check() to use a one instance of won boolean.
Previously, it was creating a boolean each time Check() was called.




this commit should of been broken up into about 10 smaller commits...
but doing so would of left the codebased in a broken state.
i prefer to push commits that don't break the program, y'know.


---------------------------------------------------------------------------------------------






bug: nothing happened when we killed all the enemies










we could probably consolidate the winLose functions into a function inside of dungeonScreen
however it's nice to have it seperate...
















move the dump state for all actors into a debug class

we need to be actually tracking summary screen data
where does this data live? global class? instance per room?
for now it can be a global class

refactor the WinLostFunctions - we're creating a boolean each check()








Version 0.1 Milestones

SOUND AND MUSIC
	when actor dashes, play dash sound
	when actor attacks, play attack sound
	when actor is hit, play hit sound
	when actor dies, play destroyed sound
	won state should have a happy jingle
	lost state should have a sad/evil jingle
	if hero has low health (<2 hearts), play drum track
	play the dungeon background music (fade out and stop when won/lost screen appears)
	fade in bkg music when dungeon is restarted/remade
	
RELEASE v0.1
	record .gif of playing through dungeon room for v0.1
	show summary screen, should be a 'dungeon complete' state



	
	
	
	
	
	
	
	




	
	
Version 0.2 Milestones

	on sword collision, create a hit particle
	create hit particle gameObject
	add to gameObjFunctions.SetType + ProjectileSpawn

	implement a fireball projectile that moves across frames
	rotate the fireball sprite to face down (all projectiles + weapons should face down by default)
	this is spawned from the Y button press
	visually display fire magic medallion for current item in worldUI
	
	when a blob is destroyed, a destroyed effect should happen, and loot should be dropped
	which means we need a destruction particle effect
	which means we need to create loot items
	
	hero should be able to pick up basic loot items (hearts, gold)
	which means hero should have a gold int
	and we'll need to check collisions between hero and projectiles (items)
	
	create pause screen, can select different weapons / items
	also displays total gold
	
	expand weapons to include moar { sword, bow, staff, axe, net }
	link pause menu to weapon enum
	
	create shop sreen, can purchase different weapons / items for gold
	implement purchasing routines (gold)
	
	create overworld screen, with selectable dungeon / shop locations
	these lead to DungeonScreen or ShopScreen
	
	play overworld music for overworld screen
	play shop music for shop screen
	
	implement additional weapons / items
	weapons : { bow, staff, axe }
	items : { lightning, boomerang, arrow, bomb }
	
	
	
	
	
	
	
	
	
Version 0.3 Milestones

	adopt CursedCastle's roomData approach (Editor -> XML -> Randomly Choose a Room)
	update dungeon generation routines to build complete dungeons
	create room editor, standardize room sizes
	
	
	
	
	
	
	
	
	
	
	
Maybes / Ideas	
	
	
	
blobs should vomit a cloud, which acts as a close range projectile, with a short lifetime
or they can use a weapon, like a stick or gooey hand, idunno


each actor should have a weapon enum

	
debugInfo displays the floor index, instead of the # of floor tiles used currently
which isn't really a problem, cause we're going to optimize how floors are drawn later on

OPTIMIZATION
if we don't draw the floor tiles, the draw loop is much faster
so, we could standardize the room sizes, then create a floor sprite
then instead of drawing 200 floor sprites, we just draw 1 larger floor sprite	
	
define room.cs, which describes the width and height of a room, and has a .type enum
	create a room instance, then pass that to the room creator routine
	place enemies all around within the room, they should not overlap
	place hero in the center of the room
	
add editor buttons to top of window: draw collisions on/off

dungeon.cs
	a collection of rooms (including an exit, hub, key, + boss room)
	draws the current room
	
room.cs
	rectangle (collisionRec) : size + position
	type
	
consider adding a single frame of a crouch to the dash animation
this would create some anticipation in the dash animation

load in a background sound file (to determine how much space this will take up)
this file should be loaded into the SCREEN's content manager
a screen's content manager should be unloaded when the screen exits
this allows us to load different music for different screens, without touching assets.cs

this sound file should be a set number of bars long, at the standard length
this should be mono, as compressed down as you can
can we use mp3? that would be ideal
does an mp3 get uncompressed when loaded into game? 

re-export sound files aligned to specific bar requirements
this will require some rewriting / restructuring of melodies and chords

sound manager should be handled just like screen manager
part of game, passed as ref to each screen
so a screen can just say "soundManager.whatever()"






