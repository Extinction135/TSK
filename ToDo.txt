"As we enjoy great advantages from the inventions of others,
we should be glad for an opportunity to serve others by an invention of ours,
and this we should do freely and generously."
- Benjamin Franklin	
	
Gif Capture process:
	run game in release mode
	run LiceCap, expand capture area past program window about 10 pixels on each side
	record at 30fps, open in photoshop and crop the frame down to just the game view (minus window title)
	reduce image size by half, down to original size so pixels are 1:1 ratio
	save as PSD master, then begin cutting out sections/edits
	the default time per frame (set by licecap) is perfect, do not change this
	save for web ->  GIF 32 Dithered, filesize should be under 3mb, loop forever
	test in browser to ensure proper fps
adding music:
	files are saved as .ogg and added to content pipeline, built on high quality.
	keep these files stereo, but at 22k.
adding sound effects:
	sound effects should be compressed down to 22K sample rate, mono, 16bit
VS shortcuts
	CTRL + M, O = collapse functions/regions	
new gif: 50% nearest neighbor, 32 dithered
adding a cheat:
	add value to MenuItemType enum (cheat starts as a selectable menu item)
	update MenuItem.SetType() to set cheat menuItem descriptions, titles, and initial frame.
	add menuItem to Cheat Screen.
	link neighbors, add effect, add check to SetCheatMenuItems(), playtest.
Adding GameObjs:
	make enum defs, make animFrames,
	set objType paths, add to env obj widget
	playtest in field.	
	
	
Phase 1 - version 0.1 to 0.7 (complete)
zelda with a procedural, randomly generated dungeon, and
better movement / dashing / combat on xbox one + pc.

Phase 2 - version 0.8 to 1.0
+ Miyamoto's original lttp ideas.
+ all desired functionality from lttp + other zeldas.
+ all desired functionality from other games.
+ mature, dark story + endgame content.	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
v0.8 goals

- the "shadow system"
every actor has a shadow, based on the actor size and flying state.
larger actor = large shadow, flying actor = smaller shadow (due to height off ground)
every object has a shadow, based on the obj type, size, and state.
these shadows maybe visible or not. these shadows should track to the
objects/actors each frame, AFTER the compMove component has finished processing.
these shadows are sprites that are added to actors and gameobj classes.
this will likely be part of pool, possibly just prior to drawing to ensure
they are always aligned to their obj/actor (altho this does pollute Draw)..

- houses, includes buildings, beds, interior objs

- Non-room repeating Dungeon, additional rooms
- Flying Dungeon Enemy, Minor Overworld Enemies
- Blob AI improvements - sword, arrow, bomb based on weapon / item loadout 
- blob loadouts could be randomized when room is built()

- EndlessForest Demo (shows off gameplay, complete on it's own, camera tracks to hero).
- this is randomly placed bushes / trees / grass + ANY enemy type
- room rec tracks to hero, expanded room rec cleans up anything that doesn't touch it
- as room moves, *generate random stuff just OUTSIDE of room rec*
- this means, as hero moves he is always 'finding' new stuff, even if he doubles back
- npc outside endless forest dialog = "once you go in, there's no way out..."
- later on implement magic mirror, which returns hero to overworld screen

- LIGHT WORLD & DARK WORLD
- implement enumFields for building rooms (big optimization)

- create 'boat' level, with boat captain, who has dialog with link
- offers to take link to a variety of locations, using vendor screen
- only available location is water temple, for low gold price (since link 'hires' crew)
- this level is the boat obj + a dungeon entrance obj + a bunch of water tiles (maybe a small island)
- links path is to/from the boat to the dungeon entrance

- water temple / swamp dungeon: 
	build crit path to hub, crit path to key, crit path to boss, 
	*crit path to water switch (pullable lever)
	*place water switch randomly in room/hub room
	water pullable lever flips high/low water level boolean
	when rooms are built they build high or low water levels, 
	low water levels prevent hero from passing thru rooms 
	there are low water levels in rooms along the key or boss crit path.
	hero must flip switch to access key or boss rooms, or not.
	boss is tentacles squid
	
- mountain dungeon (diff enemies, boss, dungeon sprites - but same rooms)

- room keys - these only work for the room and only unlock 1 door, and
these rooms turn all their doors into locked doors upon close, similar to puzzled rooms
link doesn't put them into inventory, he literally picks them up and takes
them to the door to unlock it. this is super mario style key gameplay.
if link's heldObj == small key, then link's interaction with locked door makes it open.
and heldObj is released().











Friday
	- record playthrus and examples of gameplay, post. 
	- release v0.72.
	- update readme.

	- create archive releases for v0.1 - v0.7. (fork, revert, release, delete.)
	- later, we can compare gameplay across versions.
	- note this is only for Dx version. UWP version tracking should start with v0.7.
	- these version archives should remain local, outside of repo folder.
	- *we should be able to record via the a20s just fine, via obs.
	
	

	
	
	
	
	
	
	



TODAY:



Water + Ditches

in the birth routine of ditch (Dug()),
we need to check and see if the ditch touches a water tile.
if it does, it needs to become the filled version of itself.
and it creates a splash particle. implemented, tested, working.
thats step 1.

Pivot

i think we're modeling filled ditches wrong.
it would be much easier to layer water ontop of the current
ditch system. instead of changing obj types, we should just 
change the sprite frame, and store the filled concept
as a boolean in the gameObj or somewhere.
we can then spread water by checking the boolean, 
instead of comparing multiple gameObj types, which
is error prone, takes more time, and has no special
attributes that make it a better solution than a boolean.
okgo.

rewrote FillDitch() to only alter the current animation
of the ditch's animation component, setting it to the filled
version defined in animation frames. playtested, working,
but only for the initial ditch that touches water tile.

removed filled ditch objects.
decision: filling ditches is a one way operation
right now - draining a ditch isn't planned for.

Plan++
we can model if a ditch is filled or empty by using
the getsAI boolean in gameObject. if a ditch is filled
with water, then it gets AI, which spreads the water.
by checking ditch.getsAI, we know if the ditch is filled
or not - instead of tediously checking the animation frames,
which is just a different flavor of the previous 
many to many problem we had with ObjTypes in Pivot above.

converted empty ditch obj defs to set getsAI false.
updated FillDitch() to set the Ditch.getsAI boolean true.
updated SetDitch() to check for filled neighbors. if there
is a filled neighbor, then the ditch being added is Filled().
this means that digging from a water tile 'out' works in-game.
playtested, working as expected.

added call to spawn splash particle to FillDitch().
this seems an appropriate place to do this, because we'd
want water to spread in a torrential water-like way,
via a series of splashes. 

playtested. i did it. it works. i'm so happy.
now lets make it better.

Water Spreading ++
lessened the interactive frame value for ditches,
which in turn sped up the spread time of water.
the random spread of water isn't bad, but perhaps
i can time it to spam the water splash sound fx
for maximum 'torrential effect'. lol.
tested, frame 15 is a fast spread that looks good. 
super happy. gifs coming soon. needs moar polish.










Filled Ditches ++

if hero interacts with a ditch that hasAI, then that ditch
is filled, and this obj should be treated the same way we treat
coastlines, so it can be included in the coastlines check..



we also need a better way of handling how filled ditches visually
transition into water tiles. the system works fine, but the visuals
could be improved. essentially, the ditch touching the water tile 
needs to have the water tile's sprite undeath it, so it's bkg matches
the bkg of the water tile. we *could* create a floor sprite at ditches
position, then set the floor tile's texture and animFrame (to water tiles).
this is likely the best approach to getting ditches looking 100%.






























*consider that actors may need interaction points*
*needed if actors want to pickup or dig, and it would be nice to see that
with more advanced enemies later on*
migrate hero's interaction rec and interaction rec functions into actor class.

*we could also consolidate gameobj_dungeon and gameobj_world into gameobj class.
while the compartmentalization is organized, its easier to just
recall the methods exist under the fun_gameObj class than split them between 3.

* add windmill obj that animates if a filled trench obj touches it
in the right neighboring tile.





Swimming++
while in the water, pressing X should Push() things infront of you.
pressing Y should Dive(). this gives hero some non lethal attack
to get enemies in the water away from him.



Boomerang++
*boomerang should only create attention particles upon hit if
it's traveling away from hero. if it's returning to hero (it's lifecounter)
then it shouldn't create ANY attention particles. this fixes
the visual bug where it can create a ton of pops when hitting
objs from certain angles / directions.













Metal Gear ++

if you're carrying an obj and press B while not moving, link
should squat down and the heldObj should sort mostly over his head,
and he should flip the actor.hidden boolean. then update functions_AI
to check the actor.hidden boolean instead of the actor.underwater
boolean. then update the underwater rountines to set the actor.hidden
boolean to true when actor dives underwater. the net effect of these
changes is that the hero will be able to hide underwater, underwater
while carrying an obj, or on land while carrying an obj. 
being able to hide on land while carrying an obj is more metal gear
than being able to dive while holding an obj. lol.










Boss & Miniboss

*we have big eye boss, with hit state and idle blink,
so we *could* make him the boss of the dungeon, and move big blob
into the hub as a miniBoss, which would be awesome.

the eye boss should spawn throw bombs towards hero with great force.
while also defensively moving away from hero. also, boss should be
invincible to bombs, because that's his main weapon, and we wouldn't 
want him killing himself. he should also have alot of health.




in hard mode, pits should deal 1 damage.
in normal mode, pits deal no damage.












easy underground dungeon idea:
we have an overworld pit with stairs sprite.
hide this randomly under an object that can be destroyed,
like a bush on a level. for now, this object will
create a new type of dungeon, an underground dungeon.
this is just a single critical path from hub room to exit room.
just a hub room, then an exit room south of it.
in the hub room, a miniboss will spawn, with a chest.
the chest will have the dungeon map, in case we decide to expand
this dugneon algorithm to be more than 2 rooms in the future.
but, this reverses the dungeon - leading to the exit.
upon exit, we simply return hero to his last overworld location,
which should be stored in save data.
*these dungeons should be blob enemy only, because this is story*








