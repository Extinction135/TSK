"As we enjoy great advantages from the inventions of others,
we should be glad for an opportunity to serve others by an invention of ours,
and this we should do freely and generously."
- Benjamin Franklin	
	
Gif Capture process:
	run game in release mode
	run LiceCap, expand capture area past program window about 10 pixels on each side
	record at 30fps, open in photoshop and crop the frame down to just the game view (minus window title)
	reduce image size by half, down to original size so pixels are 1:1 ratio
	save as PSD master, then begin cutting out sections/edits
	the default time per frame (set by licecap) is perfect, do not change this
	save for web ->  GIF 32 Dithered, filesize should be under 3mb, loop forever
	test in browser to ensure proper fps
adding music:
	files are saved as .ogg and added to content pipeline, built on high quality.
adding sound effects:
	sound effects should be compressed down to 22K sample rate, mono, 16bit
VS shortcuts
	CTRL + M, O = collapse functions/regions	
new gif: 50% nearest neighbor, 32 dithered
adding a cheat:
	add value to MenuItemType enum (cheat starts as a selectable menu item)
	update MenuItem.SetType() to set cheat menuItem descriptions, titles, and initial frame.
	add menuItem to Cheat Screen.
	link neighbors, add effect, add check to SetCheatMenuItems(), playtest.
Adding GameObjs:
	make enum defs, make animFrames,
	set objType paths, add to env obj widget
	playtest in field.	
	
	
	
	
	
	
	
	
	
	
	
	
	
v0.7 goals
x - divide spritesheets up so they can be expanded / modified easily
x - get all objects integrated into the new system / layout
X - expand RoomBuilder to include the creation, placement, loading and saving of world levels.
X - Outside Town Level, vendors

X - Dungeon Entrance Level, dungeon entrance object
X - obj linked to dungeon generation + extensive testing

- picking up, carrying, throwing objs
skull pots, pots, bushes - all deal 1 damage

- the "shadow system"
every actor has a shadow, based on the actor size and flying state.
larger actor = large shadow, flying actor = smaller shadow (due to height off ground)
every object has a shadow, based on the obj type, size, and state.
these shadows maybe visible or not. these shadows should track to the
objects/actors each frame, AFTER the compMove component has finished processing.
these shadows are sprites that are added to actors and gameobj classes.
this will likely be part of pool, possibly just prior to drawing to ensure
they are always aligned to their obj/actor (altho this does pollute Draw)..


- healers house, full death/respawn loop in game
- this includes buildings, beds, interior objs

- Non-room repeating Dungeon, additional rooms
- Flying Dungeon Enemy, Minor Overworld Enemies
- Blob AI improvements - sword, arrow, bomb based on weapon / item loadout 
- blob loadouts could be randomized when room is built()

- EndlessForest Demo (shows off gameplay, complete on it's own, camera tracks to hero).
- this is randomly placed bushes / trees / grass + ANY enemy type
- room rec tracks to hero, expanded room rec cleans up anything that doesn't touch it
- as room moves, *generate random stuff just OUTSIDE of room rec*
- this means, as hero moves he is always 'finding' new stuff, even if he doubles back
- npc outside endless forest dialog = "once you go in, there's no way out..."
- later on implement magic mirror, which returns hero to overworld screen

(2 'dungeons', 2 'locations' - colliseum + healers house)






TODAY:




Sounds++

updated ResetObject() to set hit&kill sounds to null.
updated Obj.SetType() to set hit&kill sfx per objType,
when needed, otherwise it defaults to null and no sfx plays.

updated sword vs blocking obj interactions to always 
play obj's hit sound fx and place a sparkle on obj hit.
updated various obj definitions to have hit and kill sfx.

Boomerang++

i nerfed the boomerang to where it can't destroy pots,
skulls, or bushes, but it still can activate levers & barrels.
this is to bring it more in line with it's purpose, 
which is strategic and not offensive / overpowered.

made tree stumps non-blocking, which means boomerangs
fly 'over' them now, plus hero isn't blocked by something
he could reasonably step over.

improved boomerang to play metallic or hollow sounds
based on collisions with walls/doors and bombable doors.

Particles++

fixed minor bug where ground fires weren't sorting properly
over tree stumps, while hero vs tree stumps sorted perfectly.












initially when the boomerang hits an obj, we could alter its lifetime
to where it wouldn't collide with the immediate objs for a few frames,
giving it a chance to escape and not create tons of collision/attention particles.






explosions should be able to destroy bookcases, tables, etc..
we should probably model 'explodable' as a boolean on the gameObj.
this way we can just do a single boolean check, and stuff that into setType.

what if we made a 'burned mark' obj, that we could reduce
any other gameobj to thru explosions? anything that is explodable
then becomes a burn mark, once it explodes.




loot should spawn centered to the obj that was destroyed.








link walking on tall grass should create small grass at link's feet, partially hiding them.
any grounded actor walking in tall grass should get "grassy feet".
so this is a sprite that lives in the actor class, tracks to the actor's feet,
and is only visible when actor is passively interacting with tall grass objs.



- can we 'reboot' in 1920x1080? can we have player input to set the size?
on Dx, this is easy. on UWP, this is not so easy, but also doesn't matter terribly.





























0.7 polish

- fix sounds (all sounds should 'sound' right, including the boomerang)

bush debris - hitting a bush should create leaves that travel in the direction of the hit
leaves only last for a moment, then die
blowing up a tree should create lots of leaves in random directions

when player presses A on dialog screen entering dungeon, play door opening sound.
this sound should not play when the hero spawns in the dungeon, where i think it does
it plays after the dungeon is built?

input polish
when moving the joystick diagonally, the input *should* split evenly between up and say right.
if i'm 60% up and 40% right, it should be up. right now, that diagonal just sets to right.
even if it's 90% up and 10% right, it's set to right. it should be a 50/50 split.
that will increase the precision of sloppy diagonal weapon attacks, aiming their intended direction.

hero should spawn facing up in dungeon.
hero should spawn facing down after exiting dungeon.

the net should map to the Y button, after all, it IS an ITEM.



















Then we need to create the healers house, with the spawn point being the bed.
we need a bed obj too!

then the proper death loop needs to be implmented in-game...

death loop:
if the hero is in game, then hero respawns at healers house.
if the hero dies while the game is in editor mode, then the hero comes back to life.
healer tells link that 'a mysterious stranger brought you here'.
the idea being that queen zelda can sense his suffering and disguises herself in
order to silently save him, to keep him on his path to her, as her plans intend, 
so she remains in control of everything. this should be revealed at the end of the
game, in the final dialogs.























Non-Repeating Rooms in Dungeon

we need to make rooms non-repeating in the dungeon.
it's cheap to come across the same room over and over again.

so when the dungeon is being built, we need a list of rooms (based on loaded room data)
then when we place a square room, we ID it, and strip that room off the roomsList
and if we run out of square rooms, then we just try columns, or rows.
this way the dungeon algorithm can never reach a point where there are no more rooms to use
which would be game breaking. also, we need ALOT of rooms to build from.


row rooms need to be redesigned to be MUCH better
we need more rows and column rooms, and their quality needs to be improved.





we need a flying enemy - like a BAT






in save data, we should have the fields named:
heartsMax, magicMax, bombsMax, arrowsMax.
we don't need magicTotal anymore.

do we actually use actor.compInt (this is the interaction component) ??? wtf

fix how kick sountrack volume is handled
the hero's health sets the volume of the kick soundtrack
this check should be happening in the level class, not anywhere
in the assets or music classes, because the kick volume is only
changed during the level screen's life. when the screen closes,
it should ensure the kick volume is 0. this prevents issues we've
had before where the kick volume was above 0 while player was on
different screen.

we should include a soundFXinstance on actors that points to one of the soundFX in assets
then we can set this instance in ActorFunctions.SetType()
then later just call it generically, like Actor.AttackSound.Play().
same with hit sound, death sound, use sound.










































































Implement Light World and Dark World RIGHT NOW
because we need to understand the architecture this is going to need,
before we start tacking a bunch of levels onto the system.
plus, we need to polish the transition between the dark world
and the light world..



v0.8 goals

- LIGHT WORLD & DARK WORLD
- implement enumFields for building rooms (big optimization)

- fix picking up, carrying, throwing, dropping, dragging, pushing objects
- can drag: light blocks, dungeon statues, barrels, torches on/off, chests
- can pickup, carry, throw: pots
- remove dropping pots from game, hero can only throw them

- create 'boat' level, with boat captain, who has dialog with link
- offers to take link to a variety of locations, using vendor screen
- only available location is water temple, for low gold price (since link 'hires' crew)
- this level is the boat obj + a dungeon entrance obj + a bunch of water tiles (maybe a small island)
- links path is to/from the boat to the dungeon entrance

- water temple / swamp dungeon: 
	build crit path to hub, crit path to key, crit path to boss, 
	*crit path to water switch (pullable lever)
	*place water switch randomly in room/hub room
	water pullable lever flips high/low water level boolean
	when rooms are built they build high or low water levels, 
	low water levels prevent hero from passing thru rooms 
	there are low water levels in rooms along the key or boss crit path.
	hero must flip switch to access key or boss rooms, or not.
	boss is tentacles squid
	
- can swim, 'dive', dash, and reward / pickup stuff in water
- dive: 
	in shallow water, this picks up whatever is hidden using reward state.
	in deep water, this allows hero to move 'under' some blocking objects
	diving is timed / capped at 255 frames, after that link pops his head back up
- dash:
	works the same in shallow and deep water, but can't be done while diving
	
- mountain dungeon (diff enemies, boss, dungeon sprites - but same rooms)

- room keys - these only work for the room and only unlock 1 door, and
these rooms turn all their doors into locked doors upon close, similar to puzzled rooms








v0.9 goals
??? story, secrets



v1.0 goals
??? support, testing, videos, documentation, alt marketing














