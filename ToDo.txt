"As we enjoy great advantages from the inventions of others,
we should be glad for an opportunity to serve others by an invention of ours,
and this we should do freely and generously."
- Benjamin Franklin	
	
Gif Capture process:
	run game in release mode
	run LiceCap, expand capture area past program window about 10 pixels on each side
	record at 30fps, open in photoshop and crop the frame down to just the game view (minus window title)
	reduce image size by half, down to original size so pixels are 1:1 ratio
	save as PSD master, then begin cutting out sections/edits
	the default time per frame (set by licecap) is perfect, do not change this
	save for web ->  GIF 32 Dithered, filesize should be under 3mb, loop forever
	test in browser to ensure proper fps
adding music:
	files are saved as .ogg and added to content pipeline, built on high quality.
	keep these files stereo, but at 22k.
adding sound effects:
	sound effects should be compressed down to 22K sample rate, mono, 16bit
VS shortcuts
	CTRL + M, O = collapse functions/regions	
new gif: 50% nearest neighbor, 32 dithered
adding a cheat:
	add value to MenuItemType enum (cheat starts as a selectable menu item)
	update MenuItem.SetType() to set cheat menuItem descriptions, titles, and initial frame.
	add menuItem to Cheat Screen.
	link neighbors, add effect, add check to SetCheatMenuItems(), playtest.
Adding GameObjs:
	make enum defs, make animFrames,
	set objType paths, add to env obj widget
	playtest in field.	
	
	
Phase 1 - version 0.1 to 0.7 (complete)
zelda with a procedural, randomly generated dungeon, and
better movement / dashing / combat on xbox one + pc.

Phase 2 - version 0.8 to 1.0
+ Miyamoto's original lttp ideas.
+ all desired functionality from lttp + other zeldas.
+ all desired functionality from other games.
+ mature, dark story + endgame content.	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
v0.8 goals

- the "shadow system"
every actor has a shadow, based on the actor size and flying state.
larger actor = large shadow, flying actor = smaller shadow (due to height off ground)
every object has a shadow, based on the obj type, size, and state.
these shadows maybe visible or not. these shadows should track to the
objects/actors each frame, AFTER the compMove component has finished processing.
these shadows are sprites that are added to actors and gameobj classes.
this will likely be part of pool, possibly just prior to drawing to ensure
they are always aligned to their obj/actor (altho this does pollute Draw)..

- healers house, full death/respawn loop in game
- this includes buildings, beds, interior objs

- Non-room repeating Dungeon, additional rooms
- Flying Dungeon Enemy, Minor Overworld Enemies
- Blob AI improvements - sword, arrow, bomb based on weapon / item loadout 
- blob loadouts could be randomized when room is built()

- EndlessForest Demo (shows off gameplay, complete on it's own, camera tracks to hero).
- this is randomly placed bushes / trees / grass + ANY enemy type
- room rec tracks to hero, expanded room rec cleans up anything that doesn't touch it
- as room moves, *generate random stuff just OUTSIDE of room rec*
- this means, as hero moves he is always 'finding' new stuff, even if he doubles back
- npc outside endless forest dialog = "once you go in, there's no way out..."
- later on implement magic mirror, which returns hero to overworld screen

- LIGHT WORLD & DARK WORLD
- implement enumFields for building rooms (big optimization)

- create 'boat' level, with boat captain, who has dialog with link
- offers to take link to a variety of locations, using vendor screen
- only available location is water temple, for low gold price (since link 'hires' crew)
- this level is the boat obj + a dungeon entrance obj + a bunch of water tiles (maybe a small island)
- links path is to/from the boat to the dungeon entrance

- water temple / swamp dungeon: 
	build crit path to hub, crit path to key, crit path to boss, 
	*crit path to water switch (pullable lever)
	*place water switch randomly in room/hub room
	water pullable lever flips high/low water level boolean
	when rooms are built they build high or low water levels, 
	low water levels prevent hero from passing thru rooms 
	there are low water levels in rooms along the key or boss crit path.
	hero must flip switch to access key or boss rooms, or not.
	boss is tentacles squid
	
- mountain dungeon (diff enemies, boss, dungeon sprites - but same rooms)

- room keys - these only work for the room and only unlock 1 door, and
these rooms turn all their doors into locked doors upon close, similar to puzzled rooms













Wednesday
	- swim reward, use items while swimming: bottles, any reward item
	- swim dash, swim drown, swim dive
	- blocking water objects
	- swim hit, we can use a flamethrower for water enemy test

Thursday
	- implement shovel weapon
	- create ditch sprite, ground can become ditch (any objs are removed, like grass)
	- shovel interaction with non-blocking obj removes obj and creates ditch obj.
	- ditch objs have 16x16 collrec, and look like 'deep dirt', a layer under ground.
	- the same way fire spreads (using interactive frame), we can spread water tiles
	- water tiles expand for one frame and make ditch tiles water tiles if they touch
	- then we need to implement cascading effect: low, med, high water tiles.
	- high > med > low > ditch is the spreading routine.
	- at this point link should be able to construct water channels

Friday
	- implement water temple (big lever to change water level outside).
	- this makes the temple accessible by lowering the water to reveal the entrance.
	- water temple contains additional critical path to big lever inside.
	- pulling big lever inside lowers the water level, so big key can be accessed.
	- this is done by boolean in dungeon/level, waterLevelHigh.
	- rooms on the key path are filled with high water if waterLevelHigh is true.
	- else they are filled with low level water, which simply creates the feetFX.
	*important that player knows how big levers work prior to entering water temple.
	- for now, the water temple boss and enemies are same as forest dungeon.
	
	




TODAY:





we need to test swim hit, swim dive, and swim death..
which means we need enemies on an overworld level with ponds.
the forest level is the first that comes to mind.
we should completely redesign this level.

*add enemies to forest entrance level (enemy spawns)
*add water ponds to forest entrance level too (test hiding from enemies)








Editor++

upgraded editor with shortcut for setting rotate (9).
fixed a minor bug with editor where the active tool
didn't get set when using a keyboard shortcut.


Blobs++
added all swimming sprites for blob, so blob can now do
everything hero can do: pickup, throw, carry, push, swim,
dive, dash, etc.. blob is only limited by his movement speed.


Limits++
raised roomObjs limit to 750 objs.
raised particles limit to 250.
raised pickups limit to 25.


Death++
upgraded death routines to check to see if actor dying is 
hero, and if so transforms hero back into the link actor.
this is because blobs have an empty frame when they die now.
this would cause the hero to 'dissappear' from the screen
upon death, and instead i want the same death animation
for the hero - no matter the hero's actor type. 


Playtesting
playtested - blob enemies can now swim, swim dash, and swim die.
plus their transitions on/off land are as expected.


Dead Actors on Coastlines
if an actor is dead, dont draw their feet fx anymore.
this was handled by updating coastline interactions to
check actor state. if actor is dead, the method just returns.
this prevents the feetfx from becoming visible.












(building forest dungeon entrance level)
(make church level more interesting)
(improve colliseum level too)





































*grounded non-basic enemies need full sheets (can swim)*
*basic grounded enemies will just be released() with a splash (no swim)*
*most mini-bosses / bosses are flying, so they dont have a swimming state*




interact rec hits water tile, kills hero's movement.
why? why should bail from interaction with a water tile, and coastline tiles,
altogether...






Swim Instructor NPC

we need a swim instructor NPC that stands in front of a large pond,
on the colliseum level. has dialog like:

do you know how to swim? i'm sure you do.
just hop in the water.

press B while moving to swim faster.
press X to dive underwater for a bit.

while underwater, enemies can't see you,
but you swim slower. have fun!











*we need swim reward state for hero.
this is the raised hand sprite.



objects should be able to 'fall' into water tiles upo collision.
this is a splash and a obj release()



*** improve colliseum level to include water areas
**** create new dungeon rooms with water tiles added





































Swimming ++

actor states in water:
x	idle
x	move
x	dash (forward B)
	raise hand (no direction B)
x	hit
	dive swim (forward X)
	dive (no direction X)
	reward

...









Editor++
prior to loading a room, set the key and map to false in editor.
this will ensure the level is loaded in properly, and the cheats
can be modified before or after at will without breaking anything.





Dancing
standing still, press B to make link randomly dance
animFrames, input check, dance state, randomly choose animFrame.
dance ends with any input, because no statelock, but animLoops.
or does it? maybe hold down B to loop. press it once to play
a random dance once.



*add in wooden table, should be easily destructable (handle common obj)







TRENCH SYSTEM (OMG I DID IT)

how to make trench system work:
the initial trench obj placed is a temp obj with a 20x20 collision rec.
on it's first frame, it checks to see what trench objs overlap it.
using the list of overlapping trenches nearby, sort to a NSEW boolean list.
(this is done by comparing new trench sprite pos to neighbor sprite pos.)
then we can switch the type of the trench just placed to 'fit' into
it's neighboring trenches. N+S = vertical. E+W = horizontal.
N+(E/W) etc = corner trench. N+S+E+W = quad trench. we only need 3 trench sprites. lol.
this makes it easy to propagate water thru them too, as we would then
have low, med, filled sprite versions of the trench.

we will also need 'end caps' that connect to straight pieces.
and trenches that are just single holes in the ground.



mirage effect from snes:

for a set of pixels, copy the top left pixel into the rest.
then simply animate the size of the pixel set over time
4 pixels, then 8, then 16, etc.. this causes the 'warp' effect
on screen (pixelization). 
this is likely something we'd have to do as a shader effect,
or possibly as a final step over the 640x360 render surface.










