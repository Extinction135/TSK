

"As we enjoy great advantages from the inventions of others,
we should be glad for an opportunity to serve others by an invention of ours,
and this we should do freely and generously."
- Benjamin Franklin	


there are 4 types of commits:
	1. adding a feature
	2. fixing a bug
	3. refactoring / reorganizing
	4. testing & profiling
	
Gif Capture process:
	run game in release mode
	run LiceCap, expand capture area past program window about 10 pixels on each side
	record at 30fps, open in photoshop and crop the frame down to just the game view (minus window title)
	reduce image size by half, down to original size so pixels are 1:1 ratio
	save as PSD master, then begin cutting out sections/edits
	the default time per frame (set by licecap) is perfect, do not change this
	save for web ->  GIF 32 Dithered, filesize should be under 3mb, loop forever
	test in browser to ensure proper fps

CTRL + M, O = collapse functions/regions
CTRL + M, P = expand functions/regions

adding a new particle/projectile:
	add new gameObject type for PP
	add new gameObject animation list for PP
	add codepath for PP to GameObjectFunctions.SetType.
	add call to spawn PP somewhere
	maybe set the alignment of PP in ProjetileFunctions.AlignProjectile()
	maybe projectile interacts with Actor/Obj in InteractionFunctions.Handle()

adding music:
	music should be compressed down to 22K sample rate, mono.
	files are then saved to .ogg and added to content pipeline, built on high quality.
	
ram useage:
	98mb on Win10. 98mb on XboxOne.
	
	
	
	
	
todo:

7



Adding Room Builder/Editor - Part 6

we want to populate the room builder widget with game objects.
we want to draw all the widget's objects.

created NewRoomScreen mockup, simplifying a previous design.
removed the overrided Reset() method from RoomBuilder widget.
this is because the room builder widget would never be reset.
this also makes me question if every widget should have a reset method - as most widgets don't reset.
that's something to deal with later tho.

created a gameobj instance, and a list of gameobjs for room builder widget.
hardcoded room builder widget's window position and size.
added path to populate the objList with correct number of gameObjs, based on row * columns from mockup.
added region to set the object.type properly, based on row and column position
added path to draw the object's sprite 
added path to draw the object's collision rec, based on Flags.DrawCollisions boolean.
added path to draw the cursor's collision rec (to room builder screen), based on Flags.DrawCollisions boolean.

playtested, working as expected.








Adding Room Builder/Editor - Part 7

we want to be able to click on an object, and set it to the 'active' object.
we want to be able to display which obj is the active object, using a selection box sprite.







builder screen
	no hero input, only builder input (grab, drag, place, erase)
	the screen doesn't animate/update objects & actors
	the floors, room objs, and actors are drawn
	hero is set offscreen, with no player input

builder widget
	7 rows of 5 room objects
	1 row of 5 enemy actors
	move, add, erase tool sprites
	save, new, load buttons
	save / load opens a file dialog
	new opens the new room screen

new room screen
	there is no new room widget, it's just the screen
	three buttons, some text
	arrow button cycles thru standard, row, column, exit, hub, key, boss enum values
	create button creates a basic room of the enum value
	cancel exits the screen
	one of the issues here is that we'll need to make sure the floor pool has enough sprites to create the larger rooms
	this will also increase the drawtime on the xbox one
	

	
download and add new music tracks to game
check ram footprint
	
	
	
	
	
	
	
Version 0.5 Milestones

	ROOM EDITOR + ROOM DATA
	build the room editor screen
	standardize all room types + sizes
	create the room data folder, update cs project to copy room data to output folder
	basically the same approach as CC, but we'll be storing the room data in a slightly diff format
	we'll only store room objects + enemy spawn locations - no floors, projectiles, etc..
	and we'll only need to store the object's enum value
	this will be stored in a 2d list of Column{Rows}.
	so row1 = {0,0,0,0,0,10,10,10,0,0,0,0,0} for example, where 10 is an object type and 0 isn't.
	this was we don't have to store position data, we just correlate rows to room width, and columns to room height
	width and height is set based on room type, so we'll need to save room type.
	but thats it. room type + the 2d array of int values.
	pretty compact and efficient.
	
	COMPLETE DUNGEONS
	we'll be using room editor to build up the room data folders.
	then when we build the dungeon, we'll load all the room data into the game at once.
	when we need a specific type of room, we just copy the necessary room data.
	then we place the room where we need it, and build it.
	this is done over and over again, until the complete dungeon is built.
	we'll use the same routines from CC to build the Exit -> Hub -> KeyPath -> BossPath layout.
	
	adopt CursedCastle's roomData approach (Editor -> XML -> Randomly Choose a Room)
	update dungeon generation routines to build complete dungeons
	create room editor, standardize room sizes
	
	
	
	
	
	
	
	
	
	
	
	
	
Polish

	implement the following items:
	item boomerang - just like LttP boomerang, hits an enemy for 1, can 'collect' pickups
	weapon staff - creates a magic orb projectile, if magic is max, else has an attack of 0, but pushes
	equipment pearl - wtf does this do in game?	
	
	we need an enemy that shoots arrows (new enemy type, not just blob with bow)
	we need an enemy that shoot fireballs (new enemy type, wizard?)	

	minor bug:
	the loadout animates the loadout menuItems
	when we select a laodout menuItem from inventory screen, we animate the loadout menuItem again
	this leads to a double scaling down effect, which should happen
	we shouldn't be able to select loadout menuItems.
	this solves the scaling issue, and it doesn't make sense to be able to select them
	selecting an item should only equip it

	polish hearts and magic world UI
	if the hearts change value, play the heart refill sound
	if the magic changes value, play the magic refill sound
	if hero uses magic, play the magic use sound
	
	Vendor stalls / layout ++
	we need vendor 'stalls'
	stalls should have rugs under them
	vendors should not be in a line, the should be spread out
	there should be more decorations in the shop
	the 'guide' npc obj should also be in the shop
	there should be a dog actor that chases the hero around
	this dog actor is an enemy, but never attacks and has it's own AI.
	
	conveyor belts should move other game objects, like consumable items
	or other objects, like bumpers and spike blocks	

	what if we pushed the hero a little bit in the opposite direction of the fireball being cast?
	this would make it seem like the 'weight' of the fireball pushed him back	
	
	instead of an unknown menuItem, we should have a 'purchased' menuItem for items that have been bought	
	
	REPLACE BOSS MUSIC	
	re-mix the boss music, making drums much less prominent in the mix
	also, mix the drums down to mono in session - we're getting phase issues when we convert to mono later

	we should be able to turn the conveyors on and off
	this allows us to build rooms with additional complexity
	perhaps the switch turns the conveyors on/off?
	puzzle: conveyor belt that pushes the hero away from something
	solution: hit the switch, turn the belts off, so hero can move around
	we could even put them on a timer and play a timer tick sound, suspending the music
	
	Stats MenuItems? Or Help Menu?
	we need menuItem sprites for the various stats
	strength - increases amount of physical damage weapon does
	magic = increases amount of magical damage magic does
	agility = how quickly hero moves + dashes
	luck = increases amount of gold found + rewarded

	pull all the sound effects from links awakening

	we could add a spear projectile for blob enemies

	it would also be fairly easy to add the flamethrower obj
	which duplicates the functionality of casting a fireball, just like hero does


	
	
Stuff that needs to be done, but it's not terribly important rn	
	
	we need a fairy projectile
	this projectile randomly moves around, slowly
	if the fairy collides with hero, it restores his health and magic
	later on, if the hero is attacking with a net, and the net hits the fairy
	we'll put the fairy in a bottle, if the fairy bottle is empty

	pickup and throw
	hero should be able to pickup the skull pot objects
	hero should be able to carry the skull pot objects around
	hero should be able to throw the pots in a direction
	pots should travel for a bit, with a shadow, before colliding with ground
	pots should also collide with room objects
	pot should have sound for pickup, throw, explode/death
	pots should randomly spawn loot too, when they are picked up
	
	dragging/pushing/pulling
	hero should be able to 'grab' objects
	if the object is draggable, then hero should be able to push and pull on it
	this 'grabbing' state should last until player releases the A button
	objects should inherit the movement of hero, and check collisions with all objs & actors
	if a draggable object would collide, it doesn't move
	
	audio ctrls sprite could be animated (sound waves growing)
	video ctrls sprite could be animated too
	fireball should have a cooldown, so hero can't spam them..

	later in development, when we have a game options screen,
	the options widget will need to reset it's neighbors, so it doesn't connect to widgets not visible
	these menuItem neighbors will be set when the inventory screen is created
	
	we'll reuse options window on the title screen, and info window

	we need to implement the empty heart idea in the worldUI
	this means hero should have values for current hearts, and maximum hearts
	maximum hearts can never exceed 14
	
	we should include a soundFXinstance on actors that points to one of the soundFX in assets
	then we can set this instance in ActorFunctions.SetType()
	then later just call it generically, like Actor.AttackSound.Play().
	same with hit sound, death sound, use sound.

	add wall pillar decorations when room is built
	doors should have decorations around them as well
	
	implement additional weapons / items
	weapons : { bow, staff, axe }
	items : { lightning, boomerang, arrow, bomb }
	
	
	
	
Maybes / Ideas	

	blobs should vomit a cloud, which acts as a close range projectile, with a short lifetime
	or they can use a weapon, like a stick or gooey hand, i dunno

	debugInfo displays the floor index, instead of the # of floor tiles used currently
	which isn't really a problem, cause we're going to optimize how floors are drawn later on

	OPTIMIZATION
	if we don't draw the floor tiles, the draw loop is much faster
	so, we could standardize the room sizes, then create a floor sprite
	then instead of drawing 200 floor sprites, we just draw 1 larger floor sprite	


	
	
	
	
	
	
	
Taking it Further

	design dungeons as a whole
	dungeons should have a theme
	there should be 'architectural puzzles', where the dungeon changes in some way
	this could be raising/lowering water levels
	moving forward/backwards in time
	destroying parts of the dungeon/rooms
	using switches to alter the paths thru rooms, or alter the nature of rooms
	for example, turning conveyo belts on/off, or spike traps
	
	in addition to these architectural puzzles, dungeons should also have a key item
	this key item must be collected to complete the dungeon
	for example, the hammer knocks down posts
	the hookshot pulls hero across gaps
	
	there are certain zelda puzzle tropes to be followed to:
	block puzzle - move a block or series of blocks into place, to press a switch / chest / etc
	enemy puzzle - kill all enemies / miniboss / boss
	shooting puzzle - shoot an eye or some object with an arrow / boomerang / projectile
	torch puzzle - light 3-4 torches
	
	
	
	
	
	
	
	
	
	
	
	
