"As we enjoy great advantages from the inventions of others,
we should be glad for an opportunity to serve others by an invention of ours,
and this we should do freely and generously."
- Benjamin Franklin	
	
Gif Capture process:
	run game in release mode
	run LiceCap, expand capture area past program window about 10 pixels on each side
	record at 30fps, open in photoshop and crop the frame down to just the game view (minus window title)
	reduce image size by half, down to original size so pixels are 1:1 ratio
	save as PSD master, then begin cutting out sections/edits
	the default time per frame (set by licecap) is perfect, do not change this
	save for web ->  GIF 32 Dithered, filesize should be under 3mb, loop forever
	test in browser to ensure proper fps
adding music:
	files are saved as .ogg and added to content pipeline, built on high quality.
adding sound effects:
	sound effects should be compressed down to 22K sample rate, mono, 16bit
VS shortcuts
	CTRL + M, O = collapse functions/regions	
new gif: 50% nearest neighbor, 32 dithered
adding a cheat:
	add value to MenuItemType enum (cheat starts as a selectable menu item)
	update MenuItem.SetType() to set cheat menuItem descriptions, titles, and initial frame.
	add menuItem to Cheat Screen.
	link neighbors, add effect, add check to SetCheatMenuItems(), playtest.
Adding GameObjs:
	make enum defs, make animFrames,
	set objType paths, add to env obj widget
	playtest in field.	
	
	
Phase 1 - version 0.1 to 0.7 (complete)
zelda with a procedural, randomly generated dungeon, and
better movement / dashing / combat on xbox one + pc.

Phase 2 - version 0.8 to 1.0
+ Miyamoto's original lttp ideas.
+ all desired functionality from lttp + other zeldas.
+ all desired functionality from other games.
+ mature, dark story + endgame content.	
	
	
	
	
	
	
	
	
	
	
v0.8 goals

- the "shadow system"
every actor has a shadow, based on the actor size and flying state.
larger actor = large shadow, flying actor = smaller shadow (due to height off ground)
every object has a shadow, based on the obj type, size, and state.
these shadows maybe visible or not. these shadows should track to the
objects/actors each frame, AFTER the compMove component has finished processing.
these shadows are sprites that are added to actors and gameobj classes.
this will likely be part of pool, possibly just prior to drawing to ensure
they are always aligned to their obj/actor (altho this does pollute Draw)..

- healers house, full death/respawn loop in game
- this includes buildings, beds, interior objs

- Non-room repeating Dungeon, additional rooms
- Flying Dungeon Enemy, Minor Overworld Enemies
- Blob AI improvements - sword, arrow, bomb based on weapon / item loadout 
- blob loadouts could be randomized when room is built()

- EndlessForest Demo (shows off gameplay, complete on it's own, camera tracks to hero).
- this is randomly placed bushes / trees / grass + ANY enemy type
- room rec tracks to hero, expanded room rec cleans up anything that doesn't touch it
- as room moves, *generate random stuff just OUTSIDE of room rec*
- this means, as hero moves he is always 'finding' new stuff, even if he doubles back
- npc outside endless forest dialog = "once you go in, there's no way out..."
- later on implement magic mirror, which returns hero to overworld screen

- LIGHT WORLD & DARK WORLD
- implement enumFields for building rooms (big optimization)

- fix picking up, carrying, throwing, dropping, dragging, pushing objects
- can drag: light blocks, dungeon statues, barrels, torches on/off, chests
- can pickup, carry, throw: pots
- remove dropping pots from game, hero can only throw them

- create 'boat' level, with boat captain, who has dialog with link
- offers to take link to a variety of locations, using vendor screen
- only available location is water temple, for low gold price (since link 'hires' crew)
- this level is the boat obj + a dungeon entrance obj + a bunch of water tiles (maybe a small island)
- links path is to/from the boat to the dungeon entrance

- water temple / swamp dungeon: 
	build crit path to hub, crit path to key, crit path to boss, 
	*crit path to water switch (pullable lever)
	*place water switch randomly in room/hub room
	water pullable lever flips high/low water level boolean
	when rooms are built they build high or low water levels, 
	low water levels prevent hero from passing thru rooms 
	there are low water levels in rooms along the key or boss crit path.
	hero must flip switch to access key or boss rooms, or not.
	boss is tentacles squid
	
- can swim, 'dive', dash, and reward / pickup stuff in water
- dive: 
	in shallow water, this picks up whatever is hidden using reward state.
	in deep water, this allows hero to move 'under' some blocking objects
	diving is timed / capped at 255 frames, after that link pops his head back up
- dash:
	works the same in shallow and deep water, but can't be done while diving
	
- mountain dungeon (diff enemies, boss, dungeon sprites - but same rooms)

- room keys - these only work for the room and only unlock 1 door, and
these rooms turn all their doors into locked doors upon close, similar to puzzled rooms














TODAY:







Explosions++

updated explosions to always leave ground fires behind.
playtested, working but not quite right.

groundfires from explosions should happen on the projectiles birth.
they seem to 'lag' after the explosion too much. feels wrong.
updated projectile functions.spawn to create ground fire for
birth of explosion projectile. centered ground fire to explosion.



Bushes ++

ground fires should be able to spread to bushes as well.
this means we can burn lines of bushes (should spread across bushes).

this was implemented in interaction functions obj v obj,
and i removed fire's ability to burn trees. why? because the 'burn trees'
method looked more like it was blowing the trees up. so, i'll
split this into BurnTree() and ExplodeTree(), where explosions blow
trees up, and ground fires burn them.
playtested, working great.





















Trees++

blowing up a tree and burning a tree is different.
blowing up shoots leaves everywhere, is instant, leaves groundfire..
burning starts with ground fire at base of tree, then top part sets on fire,
then the tree becomes the burnt version, not the tree stump.
(we have burnt version in dev, add to level sheet)

ground fire needs to have a soundFX of fire burning (quietly tho).



the forest dungeon entrance should be blocked by trees, requiring link
to blow them up with bombs to gain access to dungeon.











we should be using the light world
version of the dungeon entrance.






separate info from widgets drawing.
we should be able to draw bottom info separate from widgets. why cant we?










when player presses A on dialog screen entering dungeon, play door opening sound.
this sound should not play when the hero spawns in the dungeon, where i think it does
it plays after the dungeon is built?

input polish
when moving the joystick diagonally, the input *should* split evenly between up and say right.
if i'm 60% up and 40% right, it should be up. right now, that diagonal just sets to right.
even if it's 90% up and 10% right, it's set to right. it should be a 50/50 split.
that will increase the precision of sloppy diagonal weapon attacks, aiming their intended direction.

hero should spawn facing up in dungeon.
hero should spawn facing down after exiting dungeon.








Then we need to create the healers house, with the spawn point being the bed.
we need a bed obj, building objs, healer npc (with dialog)

then the proper death loop needs to be implmented in-game...

death loop:
if the hero is in game, then hero respawns at healers house.
if the hero dies while the game is in editor mode, then the hero comes back to life.
healer tells link that 'a mysterious stranger brought you here'.
the idea being that queen zelda can sense his suffering and disguises herself in
order to silently save him, to keep him on his path to her, as her plans intend, 
so she remains in control of everything. this should be revealed at the end of the
game, in the final dialogs.










ROOMS++
also, we are building rooms randomly when hero enters them.
this is true random, as when hero reenters them, they are different.
we need to store an id with the room (xmlid, oops) and use that to get the same roomdata each build

when we change rooms, we reset the particle pool (hopefully)
when we call that reset, we should be resetting ALL particles,
even ones that are alive currently.









Non-Repeating Rooms in Dungeon

we need to make rooms non-repeating in the dungeon.
it's cheap to come across the same room over and over again.

so when the dungeon is being built, we need a list of rooms (based on loaded room data)
then when we place a square room, we ID it, and strip that room off the roomsList
and if we run out of square rooms, then we just try columns, or rows.
this way the dungeon algorithm can never reach a point where there are no more rooms to use
which would be game breaking. also, we need ALOT of rooms to build from.


row rooms need to be redesigned to be MUCH better
we need more rows and column rooms, and their quality needs to be improved.





we need a flying enemy - like a BAT






in save data, we should have the fields named:
heartsMax, magicMax, bombsMax, arrowsMax.
we don't need magicTotal anymore.

do we actually use actor.compInt (this is the interaction component) ??? wtf

fix how kick sountrack volume is handled
the hero's health sets the volume of the kick soundtrack
this check should be happening in the level class, not anywhere
in the assets or music classes, because the kick volume is only
changed during the level screen's life. when the screen closes,
it should ensure the kick volume is 0. this prevents issues we've
had before where the kick volume was above 0 while player was on
different screen.

we should include a soundFXinstance on actors that points to one of the soundFX in assets
then we can set this instance in ActorFunctions.SetType()
then later just call it generically, like Actor.AttackSound.Play().
same with hit sound, death sound, use sound.




Implement Light World and Dark World RIGHT NOW
because we need to understand the architecture this is going to need,
before we start tacking a bunch of levels onto the system.
plus, we need to polish the transition between the dark world
and the light world..






v0.9 goals
??? story, secrets



v1.0 goals
??? support, testing, videos, documentation, alt marketing



