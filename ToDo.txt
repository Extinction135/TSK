
"As we enjoy great advantages from the inventions of others,
we should be glad for an opportunity to serve others by an invention of ours,
and this we should do freely and generously."
- Benjamin Franklin	
	
Gif Capture process:
	run game in release mode
	run LiceCap, expand capture area past program window about 10 pixels on each side
	record at 30fps, open in photoshop and crop the frame down to just the game view (minus window title)
	reduce image size by half, down to original size so pixels are 1:1 ratio
	save as PSD master, then begin cutting out sections/edits
	the default time per frame (set by licecap) is perfect, do not change this
	save for web ->  GIF 32 Dithered, filesize should be under 3mb, loop forever
	test in browser to ensure proper fps

CTRL + M, O = collapse functions/regions

adding a new particle/projectile:
	add new gameObject type for PP
	add new gameObject animation list for PP
	add codepath for PP to GameObjectFunctions.SetType.
	add call to spawn PP somewhere
	maybe set the alignment of PP in ProjetileFunctions.AlignProjectile()
	maybe projectile interacts with Actor/Obj in InteractionFunctions.Handle()

adding music:
	music should be compressed down to 22K sample rate, mono.
	files are then saved to .ogg and added to content pipeline, built on high quality.
adding sound effects:
	sound effects should be compressed down to 22K sample rate, mono, 16bit
	
ram useage:
	109mb on Win10. 102.7mb on XboxOne.
	
	
	
	
	
todo:


v0.7 goals


12






Get Actors falling into Pit Objects correctly

changed how actors interact() with AnimatedPits.
Pit pulls Actor to Pit center upon collision (each frame).

Upon initial collision, a smoke puff is created above the pit.
Pit then scales colliding actor's sprite down to 0 overtime.
Pit sets and stateLocks Actor into Hit state.
At 0% scale, the actor is checked to see if he's hero or enemy.
If hero, we call Functions_Room.SpawnHeroInCurrentRoom().
We also place an attention particle at hero's respawn position.
increased zOffset for AttentionParticle so it will sort over doors and pretty mcuh everything else.
If enemy, we play actor death soundfx, then Release() the actor.

because we are scaling actors down upon pit collisions,
we'll need to ensure we scale actors back up to 100% later on.
updated SpawnHeroInCurrentRoom() to set hero.compSprite.scale to 100%.
updated Functions_Pool.GetActor() to set Actor.compSprite.scale to 100%.

bug: actors wont scale down to 0% because Animate() scales spriteComponents up or down to 100%.
solution: seperate the scaling routines from Animate(), call them when needed.

created ScaleSpriteComponent(SpriteComp), with scaling routine.
updated paths that needed MenuItems scaled up/down (most UI scales menuItems up upon selection).
updated Pool.Update() to scale entities & roomObjs up/down per frame.
for example, the bumper is scaled up upon collision and should animate scale down to 100%.
but we purposefully DO NOT scale actors up/down per frame, in Functions_Pool.Update().

playtested that hero properly falls into pits, working as expected.
playtested that enemies properly fall into pits as well.










polish the pit falling routine:

add falling sound effect, add call from pit interact()

if two actors fall into a pit at the same time,
their collision recs wont overlap, and thus will perpetually 'fall' in place

















Cracked Floor Obj
upon collision with hero, this becomes PitCollapsing obj

Pit Collapsing Obj
if this object isn't colliding with hero, it collapses (chagnes) into a Pit obj
and it places pit teeth at top and bottom of pit upon collapse

Systems Cleanup
- cleanup all systems that operated under roomObj collisions
InteractObject()
since we aren't checking roomObjs vs. roomObjs, 
we need to cleanup InteractObject().
remove all paths that handle roomObj vs. roomObj interactions.

Editor++
when we load a roomXML data file, place hero outside of room at top left
















Projectiles++
we should have mobile spikeblocks..
can we do this using projectiles? of course
spikeblock is a projectile with 255 lifetime
this 255 value is special, meaning the projectile lasts lifetime of room
we can also model various roomObjs like this as well, for example dark/lite blocks
so we could 'fake' roomObjs moving around on conveyor belts (using projectiles)

we'll need to make sure that pickups don't have a lifetime of 255.
they can have a lifetime of 254 instead.




ObjectTools++

designate a line for projectiles in object tools widget
this will display all the projectiles, and make them selectable
and allow us to place projectiles where we want to, with the direction we want to
we should be able to set the direction of blockspike to NSEW, not just hori/vert.
these projectiles should exist above enemy spawns


Add More Persistent Projectiles

wanderingFire obj
this is just like spikeblock except the obj.direction is chosen randomly upon collision
the direction cannot be the current direction however, and can only be cardinal	

protectiveFire obj
just like wandering fire, except checks to see that it's colliding with an obj
if it doesn't collide with an obj, it rotates right and moves in that direction
this means it will travel clockwise along perimeter of stationary group of objects











Explosive Barrel
we should have an explosive barrel - of course!
just like bomb, but stationary, waiting for collision

Ice tile
changes friction, which affects how quickly an obj/actor slows down
this should affect the moveComponent of objects + actors the same way

Circling Stars
just like Lttp, the circling stars turns hero into an enemy actor type
except, it's not on a timer. hero becomes enemy actor type until Circling stars collides with hero again.
this is a check: if hero.type != hero, become enemy, else become hero.













Dungeons++
link cave, forest, old castle dungeons from the overworld map
create dungeon sprite sheet for cave + forest + old castle levels
create enemies unique to the cave + forest + old castle
create bosses unique to the cave + forest + old castle

Enemies++
create tier 1, 2, 3 level enemies for all dungeons (they can be larger if you want)
dungeons should have an enemy list for each tier
then upon room build, randomly choose an enemy type from the correct tier list
for example, forest dungeon tier 1 enemies: blob, rat, snake
when room builds, any of these 3 enemy types can spawn on a tier 1 spawn obj
create enemies that fire projectiles - arrows, fireballs, bombs



Dungeons (bombable doors)++
once the dungeon's doors are created, some should randomly be changed to bombable
this will help to conceal various paths thru the dungeon and make it more interesting / nonlinear
bombable doors shouldn't appear on the map
secret rooms shouldn't appear on the map
simply ignore drawing of bombable doors + secret rooms
- Play soundfx when hero strikes a bombable door -
if hero strikes a bombable door, play a hollow sound
if hero strikes a cracked wall, play a filled 'tink' sound (metallic tap)
this is a : sword projectile collision check against objects of type door bombable + wall cracked
we'll need to add the hollow sound - we've already got the metallic tink soundFX

Music++
add overworld music
add shop music (town music)
title screeen plays title music

explosion sound needs to be shorter


Dungeons++
the exit rooms should be different for each dungeon type
but they should be the same for the dungeon type they represent
so the dungeon type feels consistent, but there is variety between dungeon types
dungeons should have names.
the dungeon name should be displayed on the map.
dungeon names could be randomly generated from a list.

Boss dialog + Boss phases
initially the boss should popup a dialog mocking player
after boss hits half health, another dialog should popup
this one talks about boss changing tactics
"you're better than i expected"
in the 2nd phase, the boss moves AWAY from the hero
so its harder for the hero to hit the boss
in first phase, the boss just randomly moves around

PITS++
falling into a pit is just instant death
hero just dies, no damage is dealt (no fairy can be used)
ends with 'you died' screen
hero is set into hit state and scaled down to 0
at 0, the hero dies
this should also happen to enemies (instant death, no loot drop)
we should prevent enemies from moving into pits / spikes on their own
they should be able to be pushed into them, however


Boss Heads -> Crystals
instead of crystals, we should collect boss's heads.
this is the same icon that appears on the overworld map for the dungeon
this would appear in inventory screen where the crystals are, but there will only be 4
these should be located on the overworld screen
upon collection of 4 boss heads, the final dungeon opens
the blob boss head is actually an eye, the bosses eye
for now, the player will collect 4 eyes
crystals widget should be renamed 'bosses defeated', bossesWidget
we'll need to update the game display data + the LSN screen to reflect the update away from crystals
we can also make the overworld map wider, to better fill the frame out


Room Goals
doors should be set to trap doors
once hero collides with them, they close
this traps hero inside room
once all enemies are defeated or switch has been flipped, trap doors become open doors
this 'completes' the room and allows hero to exit
this means that rooms should have a goal enum
{ None, DeadEnemies, Switch, Torches }


dungeon rewards++
When the hero beats a dungeon, the only reward should be the bosses head, no gold.
gold is only acquired by defeating enemies (and later on, by betting on/winning tournaments)
text should read "press any button to continue"
remove 'reward' text















v0.8 goals


Outdoor Levels
outdoor levels are handmade, and not rectangular in design
so they can't be generated procedurally 
we'll need to create a "level editor" similar to room editor
lvl editor will have more objects to place
lvl editor will also place floortiles
*which means we need to save floortiles to XML
*which means we need to load floors + rooom objs from XML
*this XML should be seperate from roomDataXML
*levelXML? these can be loaded into Assets.LevelData list

outdoor levels to build (part 1):
colliseum 
left town A, B, C, + Church
castle gate
ship


Outdoor level objects
level objects exist in a level sheet, which is a dungeon sheet
however, a level sheet doesn't necessarily have to follow the dungeon sheet layout
this is because outdoor levels will have unique objects, and no dungeon objects
each level will have it's own unique objects, which will be enum ObjType values
which means that Obj.SetType() will grow alot...
consider creating Obj.SetDungeonObj() and Obj.SetLevelObj()
this would help to break up the monolithic SetType() 
SetDungeonObj() and SetLevelObj() would be called from SetType() based on ObjGroup/Type


OutDoor Levels ++
For each dungeon, we need an outdoor level that displays the dungeon entrance
this makes it feel like the player is entering the dungeon, instead of just spawning into it
cave, forest, castle ruins, castle entrance

Overworld++
add tiny smoke particles coming out of some houses
add 'floating' animation to ship (should bob up and down)
this means it needs to be a sprite in the main sheet
make castlel ruins look more 'ruiny'















v0.9 goals

complete story outline + plot

Letters / Notes 
we could also use the map scroll sprites as a display for letters
from the hero's wife or whatever
this could serve as a way to remind player of story too
player could read a scroll and get caught up on the main plot points
> wife leaves hero, hero'c cause/journey
> invitation to final tournament, with 4 boss head requirements
these scrolls could also popup when the hero gets them
displaying alot of dialog / story plot points


implement dialog system and event booleans to track events in game

Create CheatsScreen - or this could be part of game ctrls













DungeonDesign - Taking it Further
design dungeons as a whole
dungeons should have a theme
there should be 'architectural puzzles', where the dungeon changes in some way
this could be raising/lowering water levels
moving forward/backwards in time
destroying parts of the dungeon/rooms
using switches to alter the paths thru rooms, or alter the nature of rooms
for example, turning conveyo belts on/off, or spike traps

in addition to these architectural puzzles, dungeons should also have a key item
this key item must be collected to complete the dungeon
for example, the hammer knocks down posts
the hookshot pulls hero across gaps

there are certain zelda puzzle tropes to be followed to:
block puzzle - move a block or series of blocks into place, to press a switch / chest / etc
enemy puzzle - kill all enemies / miniboss / boss
shooting puzzle - shoot an eye or some object with an arrow / boomerang / projectile
torch puzzle - light 3-4 torches
	
	
	
	
	
	



MOAR STUFFS TO DOs
	

	
title widget functionality ++
	audio/input/video/game ctrls - creates appropriate screen

audio ctrls screen
	sfx volume
	music volume
	
input ctrls screen
	bvisual representation of button controls
	
video ctrls screen
	full screen or windowed?
	
game ctrls screen
	how camera moves - follow hero or center to current room? 
	we only need to flip Flags.CameraTracksHero boolean
	
	
	
	
	
Handling corrupt game files & first run setup - part 2

if a saved game file has correct XML headers, then game will load it
any fields that match to saveData's fields will then be loaded
theoretically, we could load an XML file that has no correct fields,
and the game would never know.. 
this makes it impossible to check if the loaded data is corrupt or accurate.
only XML with malformed opening header tags will fail to load.

we need a way to check that the loaded xml is actually a game file

create a saveData instance, set all it's fields to null
then load the saveFile into the null saveData
then check each field of the saveData to see if it's not null
if any field is null, then the loaded saveFile was corrupted
however, we can probably extract some data from the corrupt file 
so we could prompt the user with a dialog that asks 'load uncorrupted data?'
'the file i loaded is corrupt. should i try to recover it?'	
	
	

	
	
	
	
Polish

	implement the following items:
	item boomerang - just like LttP boomerang, hits an enemy for 1, can 'collect' pickups
	weapon staff - creates a magic orb projectile, if magic is max, else has an attack of 0, but pushes
	equipment pearl - wtf does this do in game?	


	minor bug:
	the loadout animates the loadout menuItems
	when we select a laodout menuItem from inventory screen, we animate the loadout menuItem again
	this leads to a double scaling down effect, which shouldnt happen
	we shouldn't be able to select loadout menuItems.
	this solves the scaling issue, and it doesn't make sense to be able to select them
	selecting an item should only equip it

	polish hearts and magic world UI
	if the hearts change value, play the heart refill sound
	if the magic changes value, play the magic refill sound
	if hero uses magic, play the magic use sound
	
	Vendor stalls / layout ++
	we need vendor 'stalls'
	stalls should have rugs under them
	vendors should not be in a line, the should be spread out
	there should be more decorations in the shop
	the 'guide' npc obj should also be in the shop
	there should be a dog actor that chases the hero around
	this dog actor is an enemy, but never attacks and has it's own AI.
	
	what if we pushed the hero a little bit in the opposite direction of the fireball being cast?
	this would make it seem like the 'weight' of the fireball pushed him back	
	
	instead of an unknown menuItem, we should have a 'purchased' menuItem for items that have been bought	
	
	REPLACE BOSS MUSIC	
	re-mix the boss music, making drums much less prominent in the mix
	also, mix the drums down to mono in session - we're getting phase issues when we convert to mono later

	puzzle: conveyor belt that pushes the hero away from something
	solution: hit the switch, turn the belts off, so hero can move around
	we could even put them on a timer and play a timer tick sound, suspending the music
	
	Stats MenuItems? Or Help Menu?
	we need menuItem sprites for the various stats
	strength - increases amount of physical damage weapon does
	magic = increases amount of magical damage magic does
	agility = how quickly hero moves + dashes
	luck = increases amount of gold found + rewarded

	pull all the sound effects from links awakening

	we could add a spear projectile for blob enemies

Stuff that needs to be done, but it's not terribly important rn	
	
	we need a fairy projectile
	this projectile randomly moves around, slowly
	if the fairy collides with hero, it restores his health and magic
	later on, if the hero is attacking with a net, and the net hits the fairy
	we'll put the fairy in a bottle, if the fairy bottle is empty

	pickup and throw
	hero should be able to pickup the skull pot objects
	hero should be able to carry the skull pot objects around
	hero should be able to throw the pots in a direction
	pots should travel for a bit, with a shadow, before colliding with ground
	pots should also collide with room objects
	pot should have sound for pickup, throw, explode/death
	pots should randomly spawn loot too, when they are picked up
	
	dragging/pushing/pulling
	hero should be able to 'grab' objects
	if the object is draggable, then hero should be able to push and pull on it
	this 'grabbing' state should last until player releases the A button
	objects should inherit the movement of hero, and check collisions with all objs & actors
	if a draggable object would collide, it doesn't move
	
	we should include a soundFXinstance on actors that points to one of the soundFX in assets
	then we can set this instance in ActorFunctions.SetType()
	then later just call it generically, like Actor.AttackSound.Play().
	same with hit sound, death sound, use sound.
	
	implement additional weapons / items
	weapons : { staff, axe }
	items : { lightning, boomerang }
	
Maybes / Ideas	

	blobs should vomit a cloud, which acts as a close range projectile, with a short lifetime
	or they can use a weapon, like a stick or gooey hand, i dunno

	debugInfo displays the floor index, instead of the # of floor tiles used currently
	which isn't really a problem, cause we're going to optimize how floors are drawn later on

	OPTIMIZATION
	if we don't draw the floor tiles, the draw loop is much faster
	so, we could standardize the room sizes, then create a floor sprite
	then instead of drawing 200 floor sprites, we just draw 1 larger floor sprite	


	
Look at how stardew valley engages players
	theres so much to do and explore
	we need more to do and explore
	should be able to have a pet, like a dog
	should be able to speak with more people/npcs
	should be able to manage traders, adventurers, etc.. like assassins creed blackflag minigame
	should be able to craft advanced items, using special parts + gold
	just a ton of additional stuff layered on top of the dungeon running, that is supporting core gameplay
	

	
