CTRL + M, O = collapse functions/regions
CTRL + M, P = expand functions/regions

goal: 13 commits/day




todo:


6




added hit and dead animationGroups to ActorAnimListManager.cs
updated SetAnimationGroup() to set hit and dead animGroup to actor.state.
defined the byte4 list for actor's hit + dead animations.
updated ActorFunctions.Update() to check actor's health and set into death state.
modified how actor.lockCounter + unlock codepath is managed, now checks for death state.



** bug: when actor is set into dead state, the AI still updates it
(but it doesn't dash?) it still moves around

also, the actor collision rec should be disabled or moved offscreen when actor dies





work hit state

we'll need to check and see if an actor has <= 0 health
if this happens, the actor is statelocked into the death state + animation
we'll need a death animation + state
once in the death animation state, the actor takes no input and never unlocks



(	
	we're going to run into an issue where the projectile's collisionRec overlaps an actor across multiple frames
	this will cause the actor to take damage multiple times
	we should have an invincible boolean for actor, so the actor doesn't take damage
	this boolean should automatically flip to false after a certain count
	so we'll need an invincibility counter and a invincibility time
)
*** this should actually be the actor's HIT state
while in the HIT state, actors should be invincible
the HIT state is statelocked, and plays through its animation, then unlocks
this prevents the cross-frame damage mentioned above




on sword collision, create a hit particle
create hit particle gameObject
add to gameObjFunctions.SetType + ProjectileSpawn




get worldUI updating the hearts based on pool.hero.health
this should happen every update frame


blobs should vomit a cloud, which acts as a close range projectile, with a short lifetime






Version 0.1 Milestones

	should be able to attack the blob enemies and destroy them
	which means actors should have HP and attack values
	should have hit + death animations and states
	
	when a blob is destroyed, a destroyed effect should happen, and loot should be dropped
	which means we need a destruction particle effect
	which means we need to create loot items
	
	hero should be able to pick up basic loot items (hearts, gold)
	which means hero should have a gold int
	and we'll need to check collisions between hero and projectiles (items)
	
	worldUI should set the visual heart display based on the hero's HP
	this should be done each update
	
	implement a fireball projectile that moves across frames
	rotate the fireball sprite to face down (all projectiles + weapons should face down by default)
	this is spawned from the Y button press
	visually display fire magic medallion for current item in worldUI
	
	worldUI current item/weapon should scale up when player presses X/Y button
	should scale back down to 1.0 over update frames
	
	once all the enemies are destroyed (or hero dies), a 'won/lost' screen should appear
	screen displays total enemies killed (need to track that)
	displays total time spent in dungeon (need to track that too)
	total damage taken (track that too)
	additional gold rewarded (based on performance)
	press start button to retry (gen random room, reset tracking/player data)
	
	when actor dashes, play dash sound
	when actor attacks, play attack sound
	when actor is hit, play hit sound
	when actor dies, play destroyed sound
	won state should have a happy jingle
	lost state should have a sad/evil jingle
	if hero has low health (<2 hearts), play drum track
	play the dungeon background music (fade out and stop when won/lost screen appears)
	fade in bkg music when dungeon is restarted/remade
	
	record .gif of playing through dungeon room for v0.1
	add flashing dungeon run logo to beginning of .gif



	
	
Version 0.2 Milestones

	create pause screen, can select different weapons / items
	also displays total gold
	
	create shop sreen, can purchase different weapons / items for gold
	implement purchasing routines (gold)
	
	create overworld screen, with selectable dungeon / shop locations
	these lead to DungeonScreen or ShopScreen
	
	play overworld music for overworld screen
	play shop music for shop screen
	
	implement additional weapons / items
	weapons : { bow, staff, axe }
	items : { lightning, boomerang, arrow, bomb }
	
	
	
Version 0.3 Milestones

	adopt CursedCastle's roomData approach (Editor -> XML -> Randomly Choose a Room)
	update dungeon generation routines to build complete dungeons
	create room editor, standardize room sizes
	
	
	
	
	
	
	
	
	
	
	
	


implement fireball magic item
this is a projectile that moves
created, placed, aligned the same as sword

each actor should have a weapon enum
weapons { none, sword, bow, staff, axe, net }
	
debugInfo displays the floor index, instead of the # of floor tiles used currently
which isn't really a problem, cause we're going to optimize how floors are drawn later on

OPTIMIZATION
if we don't draw the floor tiles, the draw loop is much faster
so, we could standardize the room sizes, then create a floor sprite
then instead of drawing 200 floor sprites, we just draw 1 larger floor sprite	
	
define room.cs, which describes the width and height of a room, and has a .type enum
	create a room instance, then pass that to the room creator routine
	place enemies all around within the room, they should not overlap
	place hero in the center of the room
	
add editor buttons to top of window: draw collisions on/off

dungeon.cs
	a collection of rooms (including an exit, hub, key, + boss room)
	draws the current room
	
room.cs
	rectangle (collisionRec) : size + position
	type
	
consider adding a single frame of a crouch to the dash animation
this would create some anticipation in the dash animation

load in a background sound file (to determine how much space this will take up)
this file should be loaded into the SCREEN's content manager
a screen's content manager should be unloaded when the screen exits
this allows us to load different music for different screens, without touching assets.cs

this sound file should be a set number of bars long, at the standard length
this should be mono, as compressed down as you can
can we use mp3? that would be ideal
does an mp3 get uncompressed when loaded into game? 

re-export sound files aligned to specific bar requirements
this will require some rewriting / restructuring of melodies and chords

sound manager should be handled just like screen manager
part of game, passed as ref to each screen
so a screen can just say "soundManager.whatever()"






