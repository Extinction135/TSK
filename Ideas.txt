








EDITOR +++++++++

editor++
it would be nice to be able to toggle roofs on/off.
and hide their collisionrecs too, so we can't accidentally pick them up.
it would also be nice to "lock" water tiles somehow, so we can't
mess them up. maybe different selection modes: landscape, building.
it would be nice to be able to drag select a rec around a set of objects,
then move them with the arrow keys, in 16 pixel increments. this would allow
us to edit parts of rooms just like we edit pixels in photoshop.


Magic Mirror
- returns link to dungeon entrance.
- plays warp sound fx
should call Level.BuildLevel(Level.ID),
which will cause the level to fade in from black,
and place hero at the entrance the dungeon again.
*this should only work in a dungeon. 
*magic mirror doesn't warp hero out of dark world
back to light world like lttp did. 
instead, magic mirror "reflects link's true image,
keeping him human in the dark world".

Whe link is first pulled into the dark world,
his magic mirror should get cracked, so he becomes
the familiar bunny again. this time he has to seek 
out someone who can repair his magic mirror before
he can become himself again. during this time,
bunny link can only walk, dash, interact, pickup,
throw, hide/sneak, swim, dive, and swim dash.
no attacking or using items. the idea is to 
make this part of the game a stealth mission:
sneak past the overpowering enemies as a bunny,
repair your magic mirror, and THEN fight.




MapScreen++
add lttp's map title to dungeon map screen, outside of
the scroll sprite. rename map window title to nothing.





Hidden Seeds / Vendor Items
*if we push a shelf obj up to the farmer vendor,
he will sell you special seeds from his secret family
locker.. he mentions that he forgot about where he
put it prior to this - so the player has at least a hint.
this can be done by simply expnding the NPCs hitbox and
then checking for the obj in question.



Wind 
in the future, when Wind is
implemented, we'll likely consolidate roomObj pushing
to a single method, and check the push against a weight
integer to determine if the push should occur.
link would have a weight greater than the obj always,
so he could always push push-able objects. BUT wind
would have a weight of 0 or 1, very light, and would
only physically move objects lighter than it (not building
walls for example). however, later on - we could implement
storm magic that creates tornados or strong gusts of
wind, and we'd only need to increase the weight of the
wind to insure it pushed everything on screen, including
the hero. this weight vs weight check is very useful -
it can also determine how quickly the hero pushes an
object making it seem like larger or heavier objects
take longer to push. /rantOver.




Darkworld Map
idea: keep most of the locations the same in darkworld map,
so it seems like the two worlds are related. there can be some
different locations, sure, but don't deviate too much.
we'll need a dark world overworld map + screen.
this means we can move most functionality out of
overworld screen and into a base class, then just
change the locations, neighbors, and corresponding levels
for light + dark overworld screens.




How are Darkworld levels / dungeons handled?
the game sees no real difference between light and dark world
levels and rooms, it's really just a texture change + different
enemies + objects. 
darkworld map locations point to specific xml.
lightworld map locations point to different xml.
darkworld dungeon rooms use same roomData as lightworld dungeons.
but, darkworld dungeon has different sprites + music,
plus different enemies spawn.
*this means we can't have turtles and rats in rooms.
*instead model this as a basic roomObj enemy, 
and choose randomly from a list. maybe its a rat,
maybe it's a bat. as long as it 'fits' the dungeon, who cares.






Transitions Between Dark and Light Worlds
this happens in a level, via a special portal object.
for now, we will use lttp's standard portal, but it will
only work one way: touching this portal closes the level,
and open the darkworld or lightworld map screen, depending
on if link was in the dark or light world when he touched
the portal. this doesn't transition between rooms.



Light & Dark World Sprites
lightworld forest entrance should be opening in trees
dark world should be horrific tree trunk thing we have rn.










Force Player to Save Their Game upon an Exit

this is from inventory menu. the player's latest data
is sitting in autosave (playerData.current), and we need
to save it to one of the 3 game data files. when we call
exit, pop a save screen - hopefully player will understand
they need to save their game before exiting.















Farming
cut grass should grow into tall grass if near coastlines,
or filled ditches. implement the idea of seeds, sold by the
farmer - AFTER link fixes his crops (each time).


should be able to plant crops, water them via ditches,
and then wait for them to grow into loot or special items.

seeds are sold by the farmer, who is already implemented
in game. now, post-reward he becomes the seed vendor.
forcing the player to figure out how to regrow bushes
is the foundation of farming - watering seeds!

Seeds: DarkBeans
we should be able to purchase dark beans
growing these beans creates a dark world 
portal that link can pass thru to the dark world. 
however, dark world creatures will randomly spawn 
from this portal too, so it's extremely dangerous
to open a dark world portal. but for the first 4
seconds (255 frames) no dark world creatures will
spawn, giving the player enough time to jump through
it, which also closes the portal, and would teleport
link to the dark world level equivalent, however that
system is designed.

Seed: CloudStalk
like super mario bros, grows a beanstalk into the sky.
link asks "should i climb this? A/B".
doing so takes him to the cloud world.











Fire++
when fire expands, it should expand further vertically,
because it doesn't always transfer from bush to bush,
because bush hitboxes are small.





Enemy Spawns

standard - usually 3 hit.

easy - 1 hit, usually many or they explode.
- we have seekers, they need to be renamed.
- we also have fun floaty eye that should be mob outside of boss room

*hard - more than 3 hits, less than 10.
-we dont have a hard boss for forest dungeon yet.
-make one

Enemies++

Seeker : seeks towards player, exlodes (done)
Standard : 3 hits, with a melee attack (usually sword).

OneHit : fast moving, low melee, low health.
Distance : projectile attack (unlimited), med move, low health.
Healing : healing magic (set amount), med move, no attack.
Aggro : tank, slow, strong melee attack.
Flanking : rogue, weak, fast, with strong attack.

Miniboss : done
Boss : done

we'll need to change the enemy spawn 2, or miniboss spawn to be
Enemy_Spawn_Weak, Enemy_Spawn_Strong. later on, it's likely this 
will expand to also include Enemy_Spawn_Ranged, Enemy_Spawn_Healer,
etc...






Underground Blob Dungeon:
we have an overworld pit sprite.
hide this randomly under an object that can be destroyed,
like a bush on a level. for now, this object will
create a new type of dungeon, an underground dungeon.
this is just a single critical path from hub room to exit room.
just a hub room, then an exit room south of it.
in the hub room, a miniboss will spawn, with a chest.
the chest will have the dungeon map, in case we decide to expand
this dugneon algorithm to be more than 2 rooms in the future.
but, this reverses the dungeon - leading to the exit.
upon exit, we simply return hero to his last overworld location,
which should be stored in save data.
*these dungeons should be blob enemy only, because this is story*


Blobs need to have more weapons & items to attack and use.
can throw bombs. can attack with swords.




Pathing

We need dirt paths, without using alot of sprite space up.
we could do vert transition to dirt + hori trans to dirt,
but never actually have a dirt tile. putting two of these
together could build a path, and then we just need corners.
so, minimum of 4 - likely 6.




HitBoxes++
we're always expanding and contracting the hitBox.
we need dedicated methods for doing this.
we need to override/replace/rewrite xna's rectangle class.
but we need to keep the intersects() and contains() methods,
as they are, as fast as they are.





Exploit : Trap Door Pit Teleport

the majority of what i do as a game developer is deal
with cause and effect, how systems interact, and designing
systems that do their job BUT ALSO get along with the
other systems that exist in the global namespace (ecosphere).

currently the system designed to track what door link
went thru last is causing a problem with the system that
represents the pit's functionality. this occurs in this
particular state, and likely in others:

hero enters a puzzle room where the doors become trap
doors (this is only way to get trap doors). hero moves
to a different trap door, touching it, activating it
as the last door 'entered'. hero is then pushed, or
falls into a pit (maybe with a certain direction).
this causes the pit to pull hero in, then call 
RespawnInCurrentRoom() on the hero, teleporting him
to the last touched door, the 2nd trap door. with
enough inertia, the hero can overcome the trap door's
initial frame of pushing, and link can pop out into
the room on the other side of the 2nd trap door.
i experienced this exploit personally. not sure if
it would work on vertical North/South doors, as
it only happened to me for East/West doors.
this is *likely* what's happening, tho I'm not
exactly sure - but I do know how to fix it.

the fix is simply to remove trap doors from the
routine that sets the last 'touched' door / active door.
in fact, only open doors or bombed doors should be
set as the last / active door.




when water spreads to other tiles, it shouldn't play
the water splash soundfx, this takes waaay too long.
it should play the water walk sfx, or we should shorten
the water splash sound fx dramatically. either or.
or we should create a water spreading soundfx,
then use the splash fx shortened. i dunno.

 
  

Improve Projectile.Spawn()

*miniboss cant shoot fireballs south - why?
?= pro.spawn() assumes that the actor's collRec is 16x16 - it shouldn't.
this means only 16x16 actors can safely shoot fireballs without damaging
themselves, which is some valve level stupid. this method should take
the actor as a parameter, and then we should base the offsets FOR ALL
PROJECTILES off of the actor's collision rec width and height. this
would allow larger actors, like bosses, to SHOOT FIREBALLS. geez.

Special Attacks / Boss "USE"
bigeye uses the shut + bloodshot frames for his special.
bigeye: spawns A TON of exploding seekers while in his special.





we can handle plot/level changes like this:
we have a boolean that represents this levels state.
false loads xml data A. true loads xml data B.
the differece between A and B represents something
that happened in the story, or something the player did.
-perhaps the player killed an NPC.
-perhaps the player irrigated a farmers crops (B would have filled ditches, A wouldn't).
-theres alot we can do here.


in hard mode, pits should deal 1 damage.
in normal mode, pits deal no damage.



*consider that actors may need interaction points*
*needed if actors want to pickup or dig, and it would be nice to see that
with more advanced enemies later on*
migrate hero's interaction rec and interaction rec functions into actor class.



Implement Cane of Somara (or whatever)
this is the cane that creates blocks that are pushable.
this makes it MUCH easier to get thru dungeons, as many
rooms rely on floor switches, which link can simply
create a block over. if a block is created ontop of
a blocking roomObject, the block ...

PLATFORMS + BUILDING
i like the idea of building platforms to cross pits or areas of insta-death.
but, unlike other games we're gonna use magic here to build platforms, and we're
gonna loop this minecraft/fortnite idea back to LttP by using the cane. in lttp,
we could build platforms using the cane, but only in specific places.
what if link could build a platform anywhere he was, the direction he was facing,
right in front of him where he could step right onto it (aligned to 16px grid).
these platforms would be permanent until the life of the room too, and cost 1 magic.


Rat Hole
we should have a 'rat hole' that randomly spawns
rats in front of it. we can add this to a room,
and the room now has constant enemies.


Tattered Shawl
the shawl could change hero's default
friction value, to be lesser than normal,
making it feel like he's moving faster - kinda
like on ice.
*currently, it does nothing.

Old Tunic
what does this do? it should have a purpose.




Should be able to light link on fire.
dashing has a chance to put fire out.
water puts fire out immediately.





MetalGear++

pickup an object. press x to enter 'sneaking' mode.
while sneaking, link crouches down with object mostly
covering him, moving very slowly. enemies cannot see link
while he is sneaking in this mode. every 255 frames,
kick link out of sneaking mode, so player has to keep
managing the sneak via X button press.

as of now, we're only checking if link is underwater.
we should model this instead using a 'hidden' boolean.
if link is hidden, enemies can't see him, dont chase/attack him.
if link is underwater, he is hidden.
if link is sneaking, he is hidden.







Notes widget - local to editor menu


Floors++
we could make floors roomObjects, since we have enough
space in the roomObj pool now. this means we could have
custom floor designs in each room, because we'll be able
to save them. we can also remove floors, and the idea of
floors, from the pool + game, further simplifying the 
codebase.






Wolves
16x16 wolf actors, with stats similar to link.
aggressive if health is high, defensive if health is low.
regenerates 1 health (up to 3) every 255 frames.
wolves are spawned in packs of 4 inside the colliseum.
defeating the pack unlocks the wolf pet, available from
the pet vendor in town. wolf pet acts with normal wolf
strat, but follows link and does not attack him (is ally).
if wolf actor dies, he can be revived by link thru
simple interaction. this revives wolf back to full health.




Shadow Objects
also, we need just pure black and a black to 0% alpha transition,
so we can create atomoshperic shadows / dark areas.
link should be able to walk into these dark areas,
and the darkness should cover link completely.
these objects would exist outside of any level sheet,
and instead be part of the entities sheet, because they would
always be black.

these shadow objects should go around the colliseum entrance?








Dreams (Ideas)

clean beds appear in overworld levels (only
light world). dirty beds appear in dungeons
and in dark world. based on what level
the bed is on, it can cause different 
kinds of dreams.

clean bed: premonition dreams, which guide the
player towards the intended objective or goal
functioning similar to lttp's fortune teller.
this is concept art + music + dialog.

dirty bed, light world dungeon: creepy to weird
dreams, no premonitions, music / sounds with
black screen, concept art, random NPCs saying
random things or having non-sensical conversations.
mostly harmless and just kinda weird.

dirty bed, darkworld level: entrance to a randomly
generated dream-world dungeon, where link's objective
is to escape (find exit). Random enemies are chosen
for rooms, along with random dungeon textures for
each room. NPCs may be added to rooms randomly too,
which would spout gibberish from randomly combined
sentences and words. dying in the dungeon would
end the dream, as would finding the exit.

dirty bed, darkworld dungeon: why would you sleep
there? WHY? because this bed creates nightmares.
nightmares are special boss fights that are only 
accessible via this manner, and are incredibly
overpowered and meant to be unbeatable (unless
using cheats, lol) - but they don't affect hero's
rating or inventory post-dream. not all dreams
in these beds are nightmares, only rarely does
a nightmare appear - most of the time it's just 
the creepy dreams.

this makes beds become actually interesting 
objects, instead of just interior building decorations.
note that modifiers can be applied to dreams,
and ceertainly will be to nightmares, where the hero
only has certain equipment, or can only have 1
heatlh max, or has infinite health, or inf magic,
etc...









- mountain dungeon (diff enemies, boss, dungeon sprites)

- Non-room repeating Dungeon, additional rooms
- Blob AI improvements - sword, bomb based on weapon / item loadout 

- room keys - these only work for the room and only unlock 1 door, and
these rooms turn all their doors into locked doors upon close, similar to puzzled rooms
link doesn't put them into inventory - he literally picks them up and walks over
to a locked door then throws the key at it.
this is kinda like super mario world style key gameplay.
if obj.type == key & obj.hitBox.intersects lockedDoor.hitBox,
convert lockedDoor to openDoor, release() key.
- or - we put the key as a menuItem in inventory,
and clear that inventory item when link enters a new room (pre-build).







- create 'boat' level, with boat captain, who has dialog with link
- offers to take link to a variety of locations, using vendor screen
- only available location is water temple, for low gold price (since link 'hires' crew)
- this level is the boat obj + a dungeon entrance obj + a bunch of water tiles (maybe a small island)
- links path is to/from the boat to the dungeon entrance

- water temple / swamp dungeon: 
	build crit path to hub, crit path to key, crit path to boss, 
	*crit path to water switch (pullable lever)
	*place water switch randomly in room/hub room
	water pullable lever flips high/low water level boolean
	when rooms are built they build high or low water levels, 
	low water levels prevent hero from passing thru rooms 
	there are low water levels in rooms along the key or boss crit path.
	hero must flip switch to access key or boss rooms, or not.
	boss is tentacles squid
	
	
	
	

We still need a stationary spike block obj.
this is super easy to do, btw.






Swim Instructor NPC

we need a swim instructor NPC that stands in front of a large pond,
on the colliseum level. has dialog like:

do you know how to swim? i'm sure you do.
just hop in the water.

press B while moving to swim faster.
press X to dive underwater for a bit.

while underwater, enemies can't see you,
but you swim slower. 

try picking up objects and carrying them
into the water as well. have fun!

*this should be at the colliseum level.
make the pond an actual pool-like arrangement.







Water Temple
	- implement water temple (big lever to change water level outside).
	- this makes the temple accessible by lowering the water to reveal the entrance.
	- water temple contains additional critical path to big lever inside.
	- pulling big lever inside lowers the water level, so big key can be accessed.
	- this is done by boolean in dungeon/level, waterLevelHigh.
	- rooms on the key path are filled with high water if waterLevelHigh is true.
	- else they are filled with low level water, which simply creates the feetFX.
	*important that player knows how big levers work prior to entering water temple.
	- for now, the water temple boss and enemies are same as forest dungeon.
	
	
	
	
	
Dancing
standing still, press B to make link randomly dance.
hold B to make link loop his dance.
visit the dance vendor to choose a dance.
link can only have one dance at a time.
unlocking dances can now be side-quests.


SideQuests
Various things can be unlocked that are completely
optional: all kinds of pets, dances, weapons,
items, armor, equipment, etc... these are all
contained within NPCs.





Fishing
a fish obj can live in water tiles, hiding from link, displayed
as an underwater object. if link is swimming and uses the net,
he may catch the underwater fish in a bottle.
*we could also have a fishing minigame, where player mashes X
*using net in water could also pick up underwater objects




Windmill Sidequest Thing
windmil doesn't work because river leading to it is blocked by
debris. can blow debris up with bomb, allowing water to spread
to windmill, turning it - unlocking / opening something.
we can model if the debris has been exploded using a boolean,
and we can check this boolean when we build the level,
removing the debris if boolean is true, 
so player feels like they altered the level.
*once we teach player about windmills here, we can place
a windmill in the dark world that needs a ditch dug to it.
this could hide a dungeon entrance, for example.






WaterTemple
the water temple is accessible by changing the water level outside
via a big push lever. changing the water level is the dungeon's theme,
so the player needs to know how this mechanic works prior to entering.
once inside, the various critical paths need to be created with the
understanding that some of those rooms will be "flooded" and impassable,
and the path to the lever that drains those rooms MUST be passable,
or in this case - not flooded.



- blocking water objects (destructible via explosions, become debris)
*we can use blocking objs to block off the water dungeon entrance



mirage effect from snes:

for a set of pixels, copy the top left pixel into the rest.
then simply animate the size of the pixel set over time
4 pixels, then 8, then 16, etc.. this causes the 'warp' effect
on screen (pixelization). 
this is likely something we'd have to do as a shader effect,
or possibly as a final step over the 640x360 render surface.



*grounded non-basic enemies need full sheets (can swim)*
*basic grounded enemies will just be released() with a splash (no swim)*
*most mini-bosses / bosses are flying, so they dont have a swimming state*





Non-Repeating Rooms in Dungeon

we need to make rooms non-repeating in the dungeon.
it's cheap to come across the same room over and over again.

so when the dungeon is being built, we need a list of rooms (based on loaded room data)
then when we place a square room, we ID it, and strip that room off the roomsList
and if we run out of square rooms, then we just try columns, or rows.
this way the dungeon algorithm can never reach a point where there are no more rooms to use
which would be game breaking. also, we need atleast 10 fo each row, square, column rooms.





when we change rooms, we reset the particle pool (hopefully)
when we call that reset, we should be resetting ALL particles,
even ones that are alive currently.



player AI

assuming the player can 'see' everything on screen, this is just an AI
looping over the obj/actors/entity lists, considering active objs in it's strategy.
then once a strategy is decided upon, the proper gamepad input is setup and passed
into the game. this ai could consider player state and retreat if weak, but instead
i think the AI should just cheat and refill it's health if it gets to 0 or dies.
in other words, there's an infinite bottle of fairies in link's backpack when AI is on.
or, we could just simply turn on invincibility.






Reaper
travels around the perimeter or the room.
if link touches him, link dies. reaper is unkillable,
and can change directions randomly, or bounce like 
spikeblock, etc.. reapers would roam mostly around
dark world graveyards or death-related levels.




Arrows++

arrows should stick into objects until they expire from age.
when the arrow hits an obj, the obj becomes the arrows caster,
and arrow then tracks to it's caster with it's offset from obj (that frame).
this will cause arrows to stick into objs, even objs that move.
we can even switch this arrow projectile for a stuck arrow projectile,
that is simply decoration (we must keep arrow as projectile so it can track to caster)






wind should occasionally blow thru overworld levels
this is a global push() on all objs and actors.
link would be pushed a bit.
leaves would fly out from trees, etc..
it's a very environmental thing, but adds life.




fix how kick sountrack volume is handled
the hero's health sets the volume of the kick soundtrack
this check should be happening in the level class, not anywhere
in the assets or music classes, because the kick volume is only
changed during the level screen's life. when the screen closes,
it should ensure the kick volume is 0. this prevents issues we've
had before where the kick volume was above 0 while player was on
different screen.

we should include a soundFXinstance on actors that points to one of the soundFX in assets
then we can set this instance in ActorFunctions.SetType()
then later just call it generically, like Actor.AttackSound.Play().
same with hit sound, death sound, use sound.




input polish
when moving the joystick diagonally, the input *should* split evenly between up and say right.
if i'm 60% up and 40% right, it should be up. right now, that diagonal just sets to right.
even if it's 90% up and 10% right, it's set to right. it should be a 50/50 split.
that will increase the precision of sloppy diagonal weapon attacks, aiming their intended direction.
**this is not related to input direction, but rather it's related to how we resolve the player's
facing direction to the cardinal casting direction of the arrow projectile, for example.






The Kusanagi Sword
this sword creates gusts of wind, which push objects
actors and projectiles (specifically ground fires).
this sword is used in a challenge where link must
push fire across a field to kill a rival warlod, via
the kusanagi legend in japan. alsoknown as the sword 
of gathering clouds.





because the blob boss has a cast sprite, he should be able to cast
revive upon his dead blob spawn randomly. this makes the boss fight
that much harder.

boss should 'stomp' dash, which creates an explosion where he lands.
we should have more frames of animation for this too.

boss blob's hit animation should be longer as well.
boss blob's death animation should be gory and long.
the final blob boss death sprite should have his guts hanging out.

blob's attack is to create a blob actor at it's location
this is done randomly






X becomes dodge underwater when link is in water.
this removes use of weapons while in water, but some
items can be used, like magic, where link has a reward state.

when hero dies in water, he sinks undewater..



*we need a sunken obj particle
this should be created whenever an object is 
sunk into water. the sprite is the underwater
sprite, particle has a life of 255 frames, then
creates an attention particle and releases().
this creates the illusion of an object sinking.
we could even have the sprite animated to get smaller!





*add a signpost outside the dungeon entrance that says "forest dungeon - caution!"
we could stuff this into the interaction comp as a string.
if obj's compInt string isn't null, pop dialog displaying obj as speaker.




we should have multiple rooms, each representing a floor, with an obj that transfers
hero between floors. this is  easiest, ad we can have as many floors as needed per room.
plus these rooms form a set, so we can build puzzles across floors, using an int or byte to 
track the room's floor level (basement, ground, 1st, etc...). plus pits can just drop hero to
a lower floor/room, unless it's the lowest floor which the spawns hero back at last door.





Samurai Training + Musashi's Blade
1 heart, 1 hit kill for both contestants.
this heightens the stakes and makes every move matter,
like in a real sword fight. there is a ladder of
samurai link must defeat. at the end, he is awarded
musashi's blade, after defeating multiple samurai
at once. musashi's blade deals 5 damage when link
is under 3 hearts. risk vs reward.
this samurai training takes place in the shadow temple.
The Shadow Temple
a dark, holy place devoid of enemies or npcs, except
one - the eternal warrior. he rests before the entrance
to the trials. he explains the trials, and grants entry.













we can model height of objects with feet byte.
then we can check feet byte to see if projectile can fly over it.
smaller projectiles, like arrows, can fly over anything small. fireballs
need more space, etc... switches become 0 feet tall. levers 4 feet.
we move the interaction of objects into a realm that is familiar: height.
walls are 10 feet. then it makes sense.





use a shovel on ground, ground becomes trench obj.
every 30 frames, water tiles check to see if they touch a trech obj.
if they do, trench becomes water tile. this allows hero to dig trenches
and fill them with water. cascade effect: low water, med water, deep water
objs act the same way, high to med to low to trench. this causes the water
to visually 'rise' up over a period of 2 seconds.




Ratings Ticket
this is a menuItem that the player can select from the inventory screen
the info widget displays the current savedata's rating (k/d)
this is first 'story item'.













Final Fight With Ganon
should take place in a destructible field overworld level, 
in the dark world. and part of ganon's attacks should Push()
the hero - which means Ganon can win simply by pushing Link
out of the level, adding another layer to this boss fight.
this means the strategy changes to stay more in the center
of the level, closer to ganon, who is the largest actor in
the game. two additional reasons why this was done: 
1. ganon is a massive actor (basically 3x3, but really 4x4),
so fighting him in a traditional boss room just isn't fair.
we need a larger room, so let's use the largest room for
the largest and (hopefully) hardest boss.
2. this allows the player to leave the level at will,
if they are getting overwhelmed and dont want to die.
this could lead to some funny moments where people
bail from the fight due to stuff ganon could do/say.
bonus 3. it throws something new at the player at the
endgame, as if to say - "hey, we ain't done with suprises"
because this transforms an overworld level into a shortcut
straight into a boss fight (after some dialog). before
this, we should never use an overworld level for a boss fight.

phase 1 - just ganon, with slides + magic + summons (1 beast head)
phase 2 - ganon alternates between beast form (phase1)
and black fire form (phase2), where he creates 6 beast
heads that link must defeat before ganon toggles back
to beast form.
phase 3 - ganon "explodes" and his head flys around,
shooting fireballs very similar to "blind" from Lttp's
darkworld bosses. these fireballs leave groundfires.
phase 4 - ganon transforms into his black fire form
and has his final dialog with Link.

when ganon's level is built after the final fight,
we check the ganon battle boolean and if true,
then ganon is replaced with a roomObj called Ganon's Soul,
which Link can interact with. this is ganon essentially
trapped and powerless in the dark world, begging link
to set him free. if link sets him free, then we flip
the ganon battle boolean false, reload level, 
and start it all over again. lol.
























slow finish / build becuase we call cleanRoom() twice, which is dumb af



Darkworld hand enemy:
this is the dungeon hand enemy from the dark world forest dungeon.
drop randomly from the top of the screen, or burrows from underneath the ground.
RAPIDLY runs around (not attacking player), then burrows / hides. Has super
creepy sounds, only meant to creep out the player.



explosions should push bomb projectiles.
it would be so easy, and it would make bomb projectiles feel alive!
placing bombs next to one another would be unpredictable past 2-3 interactions



Game Intro - music: our final descent or the great expanse
(this should look very feng zhu concept art-y, with big landscapes and small ppl)
(find concept art that matches what we're describing, downrez it grayscale it.)
link on a small raft sailing towards hyrule, queens tournament poster in hand.
crashes against the shore, simply walks away from the wreckage of his boat.
walks up to the colliseum, people looking his way - half afraid, half interested.
walks up to the tournament enroll NPC, smashes down the poster.
NPC asks for the hero's name...
*pop screen to enter hero's name*
next frame is links face, scarred from years of adventure, old
dialog simply says the name the player entered.

next we jump into the 'training' section of the game.



- can we 'reboot' in 1920x1080? can we have player input to set the size?
on Dx, this is easy. on UWP, this is not so easy, but also doesn't matter terribly.
this could be modeled as an enum value in flags: if(Flags.platform == Platform.DirectX)
then we could handle rebooting the game into 1920x1080, or:
1. set window size to match monitor display resolution, enable fullscreen
2. scale game up x2, x3, x4, etc.. based on height + width available
3. center the game's renderFrame / target to the window
4. draw the game frame centered with black bars around it

- this should make the game display as large as possible while still pixel
perfect on all monitors / tvs / displays. 
***can we do this from an options menu?***




*** we could have a massive tree trunk without a top for the entrance ***
the trunk would just keep going all the way up to the top of the sprite sheet,
and we'd place the dungeon entrance near the top of the level, always.
this way, it appears like it's much bigger in game, and we can surround it
with various smaller trees to increase it's relative size.
plus, this tree looks like it belongs in the dark world. rt.


add signpost obj that hero can read to dungeon entrance level discussing dungeon.



















add animated floating clouds to the overworld screen




quad black rectangle transitions
4 black rectangles converge onto link, simulating Lttp's circular black transition
between levels, etc.. 
this will replace the level screen's overlay fading in/out



- EndlessForest Demo (shows off gameplay, complete on it's own, camera tracks to hero).
- this is randomly placed bushes / trees / grass + ANY enemy type
- room rec tracks to hero, expanded room rec cleans up anything that doesn't touch it
- as room moves, *generate random stuff just OUTSIDE of room rec*
- this means, as hero moves he is always 'finding' new stuff, even if he doubles back
- npc outside endless forest dialog = "once you go in, there's no way out..."
- later on implement magic mirror, which returns hero to overworld screen



SPIKEBLOCK++
what about a spike block that rotate right or left every 100 frames?
this would cause it to rotate around something, unlike any other spike block seen before... harumph!
this is simply a spikeblock sprite with new obj enum, as a projectile or roomObj,
it's behavior simply counts up to 100 then switches it's compMove direction thru a series
either right or left. thats it. hahahahahaa




dripping/shiny particles randomly on the trunk.

freeze an enemy, sprinkle magic powder on them, smash with a hammer = full magic pot




Implement Dynamic Shadows System

an object pool for shadows would be great
objects / actors could have a field for a shadow sprite reference
then we could store a shadow offset, which allows us to fake depth on the Z axis
if we keep the shadow in one place, while raising the obj/act, then we get depth off the ground
this also sets the stage for flying obj/actors, as they would have changing shadow positions.
this also means we need to 'unbake' the shadows from ALL objects and actors.







Fences ++
if link hits a fence obj, it should play an animation
with two frames: fence straight, and fence bent (rounded).
this will make it look like the fence was bouncing from the hit.
this can be done by creating a fence bouncing obj,
then switching the fence to bouncing version, then after
60/120 frames, the bouncing version switches to the normal
fence. should also have a fence bouncing sound effect.
we can also do this with the vertical fences. which would
be a very nice type of interaction polish.










Special Sword Attack
should be able to charge up attack and spin just like Lttp.



Improve GameObj Naming Conventions
we should shorten the dungeon_ prefix for gameObj to dun_.
and world_ to wor_ .
this will help those items better fit into the objTools widget
plus, this shortens the overall size of the roomData xml by removing chars.





ENUM FIELDS - OH MY GOD, IF THIS WORKS...
masterwork: the bitFields used in cursedCastle were FASSSST.
and we recently learned that booleans / bits are the same cost in
ram gets/sets as ints, which we can abstract into enums.
so instead of bitFields, create enumFields.
they'll be just as fast, and you can model each tile as
many different ways as you want to, for water / islands / rooms
anything.. this could actually make procedurally creating rooms
ALOT faster, because we could build the room up using two enumField
lists - one for the doors / walls, and one for the interior objs (xml objs).
we wouldn't need to do collision checking between objects, because
we'd be setting the tiles by value, and not by position (conceptually).
so, maybe we spend some time investigating enumFields...




BIG OPTIMIZATION
if we don't draw the floor tiles, the draw loop is much faster
so, we could standardize the room sizes, then create a floor sprite
then instead of drawing 200 floor sprites, we just draw 1 larger floor sprite





Lttp Stuff we're missing:

Keys!!!
**we could have 'keys' in the game, which would be temporary for the room only
the doors would shut and convert to locked versions, or only some of them would.
inside the room is a chest that contains a key. hero picks up the key, unlocks 
a door, key is used, continues on. the room resets, works the same later on.
the key would be displayed in the inventory screen as a brittle rusty key.
and when it's used, the key breaks. the flavor text says that the key will
likely break after one use.

we could lock one door randomly, or we could lock ALL THE DOORS, and then 
force the player to choose which door they want to unlock.


PULLABLE LEVERS
these are built into the wall and open shut doors, just like a switch
these must be pulled for a bit tho, and there are decoy levers that will
spawn snakes or explode..

these large levers should be reserved for dungeon changes,
like flooding the dungeon, etc.. which we could model simply 
with a boolean, which would then add shallow water to all rooms,
and change pits to deep water, making some areas PASSABLE! yes.
this is how we can procedurally shut off areas of the dungeon. ah, perfect.

example, the hub room could have a big lever that floods the dungeon
and the hero must pull the lever to flood the key room, because that
key room has a chest surrounded by pits, which is totally inaccessible.
we could also put the big lever in some random roomm, or in its own
special room, which would be present in dungeons that can undergo
structural changes (like flooding)... hmm...










DUNGEON NAMES
dungeons should have names.
the dungeon name should be displayed on the map.
dungeon names could be randomly generated from a list.




LINK FLOATING
a specific loadout should allow link to float + move, without dashing tho.
something that makes him light as a feather (armor/equip) plus the repaired
pegasus boots. note: when the pegasus boots are repaired, there is no immediate
benefit as dashing works the same before and after. it's just partA of this combo.
partB is getting the equip/armor.





UNDERWORLD DUNGEONS
there should be dungeons where the spawn room doens't contain the exit.
rather a critical path is built to the exit room, which contains a ladder
that leads up. climbing this ladder exits the hero to the overworld screen.
finding this exit is the primary objective of this dungeon type, which a
player might fall into from an overworld level. along the critical path to
the exit, the player could run into: minibosses, loot, secret rooms, branching
paths, portals, etc...

these underworld dungeons come from overworld level objects, like pits, bombable
doors, pipes, etc...





PLATFORMS + BUILDING
i like the idea of building platforms to cross pits or areas of insta-death.
but, unlike other games we're gonna use magic here to build platforms, and we're
gonna loop this minecraft/fortnite idea back to LttP by using the cane. in lttp,
we could build platforms using the cane, but only in specific places.
what if link could build a platform anywhere he was, the direction he was facing,
right in front of him where he could step right onto it (aligned to 16px grid).
these platforms would be permanent until the life of the room too, and cost 1 magic.


INCREASE MAGIC
we do need a way to increase our total magic, tho.
just like hearts, this item should be sold be the items vendor.



Arrows++
when arrow collides with a blocking obj, 
set arrow's speed to 0, increase it's friction slightly.
it should 'sink' into a final position, inside the wall,
where it will 'live' until frame 255, then be removed.
this ONLY works on blocking objects without any magnitude.
IF THE OBJ DOES HAVE A MAGNITUDE, 
then we just kill the arrow upon collision.
otherwise the obj would move, and the arrow wouldn't travel with it.
and that would look WRONG.



Slippery Slope!
*if we slide a bomb across ice, then onto grass,
the bomb keeps sliding as if it were on ice. it's a pro.
so maybe we aren't resetting the friction prior
to checking projectile interactions with roomObjs?





BURNMARKS
groundfires should leave burn mark.
explosions should leave burn mark..

EXPLOSIONS++
add 'burn' mark particle for explosions
should last for 255 frames, mark the ground dark, then fade away.
sprite.alpha = (float)obj.lifeCount * 3  //when this drops below 50frames, it will fade out
*this can be reversed if life is counting up instead..
if life > 250, alpha = 100 - (life - 250) * 2;










Explosion Surfing (Bomb Jumping)

if an actor is hit, simply put them into a flying state.
this will cause the actor to be able to fly across pits for a moment,
but when the hit state ends, if they overlap the pit, they
will be pulled in. but, this does allow a type of bomb jumping,
or rather "explosion surfing". which sounds so much better.

we could even put the actor into a 2nd type of hit state,
a staggered state, which would hold the actor in the hit state for
longer, allowing them to fly for longer, allowing them to cross
single tile pits safely - and only an explosion would be able
to set an actor into this 2nd hit staggered hit state.

which, staggered seems like a poor name for this state.
likely should be something like ExplosiveThrow, 
so we know the actor is being thrown by an explosion.

we can implement this now and ensure that bomb jumping is not
only preserved, but supported officially in this game, and is
known as explosion surfing, because you can also use fireballs
to do these type of explosive throwing tricks.











PROPERTY, BANK ACCOUNTS, + THE ECONOMY

so, the hero can only have 99 rupees on his character.
however, he can open an account that allows him to store up to 999,999 rupees,
if he pays 99 rupees at a specific location talking to a specific person.
then throughout the game, the hero can withdraw or deposit money thru a bank
representative, which are characters scattered around most vendor based levels.
this allows the player to store more money, and get access to it when needed, 
while still having to pick and choose what to buy and carry with them.
*later on, when a business is for sale, the hero must have a bank account to 
purchase the business or property, because that's how the deal is handled thru.
without a bank account, the hero wouldn't be able to possess enough money to purchase
any business or property over 99 rupees...




OVERWORLD SCREEN MAP++
add tiny smoke particles coming out of some houses
add 'floating' animation to ship (should bob up and down)
this means it needs to be a sprite in the main sheet
make castlel ruins look more 'ruiny'


MAGNETIC ISLAND
this is a set of levels where a Push() is applied to EVERyTHING each frame.
the direction could be magnetic north, or it could be changeable by object or season.


WIND + WIND MAGIC
this applies a max force Push() to everything on screen except hero, based on
the direction hero is facing. this wind magic can be re-used in game as wind, if
we turn the force down to something more manageable, play wind sound fx, and blow
leaves / dust when it happens..




PUSHWAND + LIGHTWAVE PROJECTILE

the flame throwers on the ground shouldn't shoot fireballs
they should shoot those light wave things, which dont deal damage to what they hit!
they actually only push what they hit, and they dont die upon a collision
they will continue to push whatever they collide with until they die from age
this means we need a new type of projectile, which is exciting

and we can use this wave as the projectile created from the wand!
we can call it the push wand, which would allow us to create a whole new type of puzzle
where we can use the push wand to move objects to solve rooms!!!


Projectiles++
WanderingFire 
this is just like spikeblock except the obj.direction is chosen randomly upon collision
the direction cannot be the current direction however, and can only be cardinal	
should be able to place wandering fire using tools widget


MAGIC POWDER (?)
**if you sprinkle magic powder on a dead enemy, he comes back to life at 100% hp
but, he's still your enemy, so i don't know how useful it is practically...




Circling Stars
just like Lttp, the circling stars turns hero into an enemy actor type
except, it's not on a timer. hero becomes enemy actor type until 
Circling stars collides with hero again.
this is a check: if hero.type != hero, become enemy, else become hero.



for the ice dungeon, procedurally add ice tiles to each room
if ice tile overlaps with a pit / bridge / floor spikes / cracked floor, remove it
this can be done in the cleanup of room
and we'll probably need to expand the max size of roomObjs




WorldUI++
when the hero's health changes, the worldUI should animate hearts individually
if the hero gains 5 health, each heart should scale up, then animate down
once that heart's scale reaches 1.0, then the next heart can animate
this sequential scaling should happen anytime hero's health changes



Boss dialog + Boss phases
initially the boss should popup a dialog mocking player
after boss hits half health, another dialog should popup
this one talks about boss changing tactics
"you're better than i expected"
in the 2nd phase, the boss moves AWAY from the hero
so its harder for the hero to hit the boss
in first phase, the boss just randomly moves around







Handling corrupt game files & first run setup - part 2

if a saved game file has correct XML headers, then game will load it
any fields that match to saveData's fields will then be loaded
theoretically, we could load an XML file that has no correct fields,
and the game would never know.. 
this makes it impossible to check if the loaded data is corrupt or accurate.
only XML with malformed opening header tags will fail to load.

we need a way to check that the loaded xml is actually a game file

create a saveData instance, set all it's fields to null
then load the saveFile into the null saveData
then check each field of the saveData to see if it's not null
if any field is null, then the loaded saveFile was corrupted
however, we can probably extract some data from the corrupt file 
so we could prompt the user with a dialog that asks 'load uncorrupted data?'
'the file i loaded is corrupt. should i try to recover it?'	









	
	
	
	


where do we display the kill ratio?
this is displayed in a stats widget somewhere that hasn't been designed yet
equation for determining skill rating in percentage.
this is: total enemies killed / damage taken
ex: 10/1 = 10.   245/73 = 3.35.






*************************************************************************
MAYBES (these may/not be possible?)




DungeonDesign - Taking it Further
there should be 'architectural puzzles', where the dungeon changes in some way
this could be raising/lowering water levels
moving forward/backwards in time
destroying parts of the dungeon/rooms
using switches to alter the paths thru rooms, or alter the nature of rooms
however this is done needs to exist ontop of the already built concept of
critical paths, where we procedurally build smaller crit paths to complete
the overall dungeon.


BITE from all the other awesome games you love:
	theres so much to do and explore
	we need more to do and explore
	should be able to have a pet, like a dog
	should be able to speak with more people/npcs
	should be able to manage traders, adventurers, etc.. (blackflag?)
	should be able to craft advanced items, using special parts + gold
	
	
	
Make the AI system Behavior based, where a Behavior is an enumerator

actor.behaviors = new List<Behaviors> 
{ Behavior.Aggressive, Behavior.Curious, Behavior.Destructive }
Behavior.Aggressive (actor will pursue hero without regard for safety)
Behavior.Attacks (actor will attack hero, if hero is close enough)
Behavior.Curious (actor will randomly explore the area around them)
Behavior.Destructive (actor will attack any destructible object it comes across)
Behavior.SpawnsMobs (actor can spawn other actors, based on actor.type)
Behavior.ThrowsPots (actor will pickup and throw object it comes across at hero)

an enumerator, and a list in the actor class.
then we modify the AI method to work based on behaviors.
if actor.behavior[i] == 
- aggressive, move actor towards hero, if hero is visible
- attacks, attack hero if hero is close enough
- curious, randomly move actor
- destructive, attack destructible objects nearby
- spawnsMobs, randomly spawn mobs based on the actor.type
- throwsPots, picks up nearby pots, carrys them, and throws them at hero if hero is visible










